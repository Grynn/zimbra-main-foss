--- openldap-2.4.22.3z/servers/slapd/back-bdb/dn2entry.c.orig	2010-06-20 22:27:12.658195104 -0700
+++ openldap-2.4.22.3z/servers/slapd/back-bdb/dn2entry.c	2010-06-20 22:29:44.217532584 -0700
@@ -50,6 +50,8 @@
 			/* Set the return value, whether we have its entry
 			 * or not.
 			 */
+			Debug( LDAP_DEBUG_TRACE, "====> bdb_dn2entry matched: id %ld rdn %s being deleted, state %#x\n",
+				ei->bei_id, ei->bei_nrdn.bv_val, ei->bei_state );
 			*e = ei;
 			if ( ei && ei->bei_id ) {
 				rc2 = bdb_cache_find_id( op, tid, ei->bei_id,
@@ -70,6 +72,8 @@
 			*e = ei;
 		} else if ( matched && rc == DB_NOTFOUND ) {
 			/* always return EntryInfo */
+			Debug( LDAP_DEBUG_TRACE, "====> bdb_dn2entry parent return: id %ld rdn %s being deleted, state %#x\n",
+				ei->bei_id, ei->bei_nrdn.bv_val, ei->bei_state );
 			if ( ei->bei_parent ) {
 				ei = ei->bei_parent;
 				rc2 = bdb_cache_find_id( op, tid, ei->bei_id, &ei, 0,
--- openldap-2.4.22.3z/servers/slapd/back-bdb/cache.c.orig	2010-04-15 13:06:59.000000000 -0700
+++ openldap-2.4.22.3z/servers/slapd/back-bdb/cache.c	2010-06-20 23:07:36.583439246 -0700
@@ -482,17 +482,21 @@
 				*res = eip;
 				return rc;
 			}
-		} else if ( ei2->bei_state & CACHE_ENTRY_DELETED ) {
+		}
+		bdb_cache_entryinfo_lock( ei2 );
+		if ( ei2->bei_state & CACHE_ENTRY_DELETED ) {
 			/* In the midst of deleting? Give it a chance to
 			 * complete.
 			 */
+			Debug( LDAP_DEBUG_TRACE, "====> bdb_cache_find_ndn: id %ld rdn %s being deleted, state %#x\n",
+				ei2->bei_id, ei2->bei_nrdn.bv_val, ei2->bei_state );
+			bdb_cache_entryinfo_unlock( ei2 );
 			bdb_cache_entryinfo_unlock( eip );
 			ldap_pvt_thread_yield();
 			bdb_cache_entryinfo_lock( eip );
 			*res = eip;
 			return DB_NOTFOUND;
 		}
-		bdb_cache_entryinfo_lock( ei2 );
 		bdb_cache_entryinfo_unlock( eip );
 
 		eip = ei2;
@@ -893,6 +897,8 @@
 				 * as if the delete has already finished
 				 */
 				if ( del ) {
+					Debug( LDAP_DEBUG_TRACE, "====> bdb_cache_find_id: id %ld rdn %s being deleted, state %#x\n",
+				id, (*eip)->bei_nrdn.bv_val, (*eip)->bei_state );
 					return DB_NOTFOUND;
 				}
 				/* otherwise, wait for the info to free up */
@@ -945,6 +951,8 @@
 		}
 
 		if ( (*eip)->bei_state & CACHE_ENTRY_DELETED ) {
+			Debug( LDAP_DEBUG_TRACE, "====> bdb_cache_find_id #2: id %ld rdn %s being deleted, state %#x\n",
+			id, (*eip)->bei_nrdn.bv_val, (*eip)->bei_state );
 			rc = DB_NOTFOUND;
 		} else {
 			(*eip)->bei_finders++;
@@ -987,6 +995,8 @@
 			}
 			rc = bdb_cache_entry_db_lock( bdb, tid, *eip, load, 0, lock );
 			if ( (*eip)->bei_state & CACHE_ENTRY_DELETED ) {
+				Debug( LDAP_DEBUG_TRACE, "====> bdb_cache_find_id #3: id %ld rdn %s being deleted, state %#x\n",
+				id, (*eip)->bei_nrdn.bv_val, (*eip)->bei_state );
 				rc = DB_NOTFOUND;
 				bdb_cache_entry_db_unlock( bdb, lock );
 				bdb_cache_entryinfo_lock( *eip );
@@ -996,6 +1006,10 @@
 				if ( load ) {
 					if ( !ep) {
 						rc = bdb_id2entry( op->o_bd, tid, id, &ep );
+						if (rc == DB_NOTFOUND) {
+							Debug( LDAP_DEBUG_TRACE, "====> bdb_cache_find_id #3.5: id %ld rdn %s being deleted, state %#x\n",
+							id, (*eip)->bei_nrdn.bv_val, (*eip)->bei_state );
+						}
 					}
 					if ( rc == 0 ) {
 						ep->e_private = *eip;
@@ -1113,11 +1127,16 @@
 		return 0;
 	}
 	if ( BEI(e)->bei_state & CACHE_ENTRY_NO_KIDS ) {
+		Debug( LDAP_DEBUG_TRACE, "====> bdb_cache_children: returning DB_NOTFOUND\n",0,0,0);
 		return DB_NOTFOUND;
 	}
 	rc = bdb_dn2id_children( op, txn, e );
-	if ( rc == DB_NOTFOUND ) {
+	if ( rc == DB_NOTFOUND && (BEI(e)->bei_state & 
+		( CACHE_ENTRY_NO_KIDS | CACHE_ENTRY_NO_GRANDKIDS )) !=
+		( CACHE_ENTRY_NO_KIDS | CACHE_ENTRY_NO_GRANDKIDS )) {
+		bdb_cache_entryinfo_lock( BEI(e) );
 		BEI(e)->bei_state |= CACHE_ENTRY_NO_KIDS | CACHE_ENTRY_NO_GRANDKIDS;
+		bdb_cache_entryinfo_unlock( BEI(e) );
 	}
 	return rc;
 }
--- openldap-2.4.22.3z/servers/slapd/back-bdb/id2entry.c.orig	2010-06-21 10:49:38.095094622 -0700
+++ openldap-2.4.22.3z/servers/slapd/back-bdb/id2entry.c	2010-06-21 11:00:24.195883209 -0700
@@ -117,25 +117,38 @@
 
 	/* fetch it */
 	rc = db->cursor( db, tid, &cursor, bdb->bi_db_opflags );
-	if ( rc ) return rc;
+	if ( rc ) {
+		Debug( LDAP_DEBUG_TRACE, "====> bdb_id2entry #1: returning %d\n",rc,0,0);
+		return rc;
+	}
 
 	/* Get the nattrs / nvals counts first */
 	data.ulen = data.dlen = sizeof(buf);
 	data.data = buf;
 	rc = cursor->c_get( cursor, &key, &data, DB_SET );
-	if ( rc ) goto finish;
+	if ( rc ) {
+		Debug( LDAP_DEBUG_TRACE, "====> bdb_id2entry #2.1: returning %d, key: %lx, keysize: %d\n",rc,nid,key.size);
+		Debug( LDAP_DEBUG_TRACE, "====> bdb_id2entry #2.2: id: %lx\n",id,0,0);
+		goto finish;
+	}
 
 
 	eh.bv.bv_val = buf;
 	eh.bv.bv_len = data.size;
 	rc = entry_header( &eh );
-	if ( rc ) goto finish;
+	if ( rc ) {
+		Debug( LDAP_DEBUG_TRACE, "====> bdb_id2entry #3: returning %d\n",rc,0,0);
+		goto finish;
+	}
 
 	/* Get the size */
 	data.flags ^= DB_DBT_PARTIAL;
 	data.ulen = 0;
 	rc = cursor->c_get( cursor, &key, &data, DB_CURRENT );
-	if ( rc != DB_BUFFER_SMALL ) goto finish;
+	if ( rc != DB_BUFFER_SMALL ) {
+		Debug( LDAP_DEBUG_TRACE, "====> bdb_id2entry #4: returning %d\n",rc,0,0);
+		goto finish;
+	}
 
 	/* Allocate a block and retrieve the data */
 	off = eh.data - eh.bv.bv_val;
@@ -154,6 +166,7 @@
 	cursor->c_close( cursor );
 
 	if( rc != 0 ) {
+		Debug( LDAP_DEBUG_TRACE, "====> bdb_id2entry #5: returning %d\n",rc,0,0);
 		return rc;
 	}
 
@@ -177,6 +190,7 @@
 	ch_free(eh.bv.bv_val);
 #endif
 
+	Debug( LDAP_DEBUG_TRACE, "====> bdb_id2entry #6: returning %d\n",rc,0,0);
 	return rc;
 }
 
Index: dn2id.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/dn2id.c,v
--- openldap-2.4.22/servers/slapd/back-bdb/dn2id.c	13 Apr 2010 20:18:12 -0000	1.171
+++ openldap-2.4.22/servers/slapd/back-bdb/dn2id.c	22 Jun 2010 04:22:05 -0000
@@ -754,12 +754,13 @@
 	struct bdb_info *bdb = (struct bdb_info *) op->o_bd->be_private;
 	DB *db = bdb->bi_dn2id->bdi_db;
 	DBT		key, data;
-	DBC	*cursor;
+	DBC	*cursor = NULL;
 	int		rc = 0, nrlen;
 	diskNode *d;
 	char	*ptr;
 	unsigned char dlen[2];
 	ID idp, parentID;
+	DB_TXN *tx2;
 
 	Debug( LDAP_DEBUG_TRACE, "=> hdb_dn2id(\"%s\")\n", in->bv_val, 0, 0 );
 
@@ -780,8 +781,14 @@
 	data.dlen = data.ulen;
 	data.flags = DB_DBT_USERMEM | DB_DBT_PARTIAL;
 
-	rc = db->cursor( db, txn, &cursor, bdb->bi_db_opflags );
-	if ( rc ) return rc;
+	if ( txn->flags & TXN_READ_COMMITTED ) {
+		rc = TXN_BEGIN( bdb->bi_dbenv, txn, &tx2, bdb->bi_db_opflags );
+		if ( rc ) return rc;
+	} else {
+		tx2 = txn;
+	}
+	rc = db->cursor( db, tx2, &cursor, bdb->bi_db_opflags );
+	if ( rc ) goto func_leave;
 
 	d = op->o_tmpalloc( data.size * 3, op->o_tmpmemctx );
 	d->nrdnlen[1] = nrlen & 0xff;
@@ -792,8 +799,8 @@
 	*ptr = '\0';
 	data.data = d;
 
-	rc = bdb_dn2id_lock( bdb, in, 0, txn, lock );
-	if ( rc ) goto func_leave;
+/*	rc = bdb_dn2id_lock( bdb, in, 0, txn, lock );
+	if ( rc ) goto func_leave; */
 
 	rc = cursor->c_get( cursor, &key, &data, DB_GET_BOTH_RANGE );
 	if ( rc == 0 && (dlen[1] != d->nrdnlen[1] || dlen[0] != d->nrdnlen[0] ||
@@ -819,6 +826,8 @@
 
 func_leave:
 	cursor->c_close( cursor );
+	if ( tx2 != txn )
+		TXN_ABORT( tx2 );
 	op->o_tmpfree( d, op->o_tmpmemctx );
 	if( rc != 0 ) {
 		Debug( LDAP_DEBUG_TRACE, "<= hdb_dn2id: get failed: %s (%d)\n",
--- openldap-2.4.22/servers/slapd/back-bdb/add.c	13 Apr 2010 20:18:11 -0000	1.184
+++ openldap-2.4.22/servers/slapd/back-bdb/add.c	22 Jun 2010 05:28:12 -0000
@@ -513,7 +513,6 @@
 return_results:
 	success = rs->sr_err;
 	send_ldap_result( op, rs );
-	slap_graduate_commit_csn( op );
 
 	if( ltid != NULL ) {
 		TXN_ABORT( ltid );
@@ -538,10 +537,11 @@
 		}
 	}
 
+	slap_graduate_commit_csn( op );
+
 	if( postread_ctrl != NULL && (*postread_ctrl) != NULL ) {
 		slap_sl_free( (*postread_ctrl)->ldctl_value.bv_val, op->o_tmpmemctx );
 		slap_sl_free( *postread_ctrl, op->o_tmpmemctx );
 	}
-
 	return rs->sr_err;
 }
