--- openldap-2.4.22/servers/slapd/back-bdb/cache.c	13 Apr 2010 20:18:11 -0000	1.216
+++ openldap-2.4.22/servers/slapd/back-bdb/cache.c	20 Jun 2010 19:28:04 -0000	1.217
@@ -482,17 +482,21 @@ bdb_cache_find_ndn(
 				*res = eip;
 				return rc;
 			}
-		} else if ( ei2->bei_state & CACHE_ENTRY_DELETED ) {
+		}
+		bdb_cache_entryinfo_lock( ei2 );
+		if ( ei2->bei_state & CACHE_ENTRY_DELETED ) {
 			/* In the midst of deleting? Give it a chance to
 			 * complete.
 			 */
+			Debug( LDAP_DEBUG_TRACE, "====> bdb_cache_find_ndn: id %ld rdn %s being deleted, state %#x\n",
+				ei2->bei_id, ei2->bei_nrdn.bv_val, ei2->bei_state );
+			bdb_cache_entryinfo_unlock( ei2 );
 			bdb_cache_entryinfo_unlock( eip );
 			ldap_pvt_thread_yield();
 			bdb_cache_entryinfo_lock( eip );
 			*res = eip;
 			return DB_NOTFOUND;
 		}
-		bdb_cache_entryinfo_lock( ei2 );
 		bdb_cache_entryinfo_unlock( eip );
 
 		eip = ei2;
@@ -895,6 +897,8 @@
 				 * as if the delete has already finished
 				 */
 				if ( del ) {
+					Debug( LDAP_DEBUG_TRACE, "====> bdb_cache_find_id: id %ld rdn %s being deleted, state %#x\n",
+				id, (*eip)->bei_nrdn.bv_val, (*eip)->bei_state );
 					return DB_NOTFOUND;
 				}
 				/* otherwise, wait for the info to free up */
@@ -947,6 +951,8 @@
 		}
 
 		if ( (*eip)->bei_state & CACHE_ENTRY_DELETED ) {
+			Debug( LDAP_DEBUG_TRACE, "====> bdb_cache_find_id #2: id %ld rdn %s being deleted, state %#x\n",
+			id, (*eip)->bei_nrdn.bv_val, (*eip)->bei_state );
 			rc = DB_NOTFOUND;
 		} else {
 			(*eip)->bei_finders++;
@@ -989,6 +995,8 @@
 			}
 			rc = bdb_cache_entry_db_lock( bdb, tid, *eip, load, 0, lock );
 			if ( (*eip)->bei_state & CACHE_ENTRY_DELETED ) {
+				Debug( LDAP_DEBUG_TRACE, "====> bdb_cache_find_id #3: id %ld rdn %s being deleted, state %#x\n",
+				id, (*eip)->bei_nrdn.bv_val, (*eip)->bei_state );
 				rc = DB_NOTFOUND;
 				bdb_cache_entry_db_unlock( bdb, lock );
 				bdb_cache_entryinfo_lock( *eip );
@@ -1118,8 +1126,12 @@
 		return DB_NOTFOUND;
 	}
 	rc = bdb_dn2id_children( op, txn, e );
-	if ( rc == DB_NOTFOUND ) {
+	if ( rc == DB_NOTFOUND && (BEI(e)->bei_state & 
+		( CACHE_ENTRY_NO_KIDS | CACHE_ENTRY_NO_GRANDKIDS )) !=
+		( CACHE_ENTRY_NO_KIDS | CACHE_ENTRY_NO_GRANDKIDS )) {
+		bdb_cache_entryinfo_lock( BEI(e) );
 		BEI(e)->bei_state |= CACHE_ENTRY_NO_KIDS | CACHE_ENTRY_NO_GRANDKIDS;
+		bdb_cache_entryinfo_unlock( BEI(e) );
 	}
 	return rc;
 }
