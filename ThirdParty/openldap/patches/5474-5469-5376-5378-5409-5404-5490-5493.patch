diff -dur openldap-2.3.41/servers/slapd/back-bdb/search.c openldap-2.3.42/servers/slapd/back-bdb/search.c
--- openldap-2.3.41/servers/slapd/back-bdb/search.c	2008-02-11 15:24:19.000000000 -0800
+++ openldap-2.3.42/servers/slapd/back-bdb/search.c	2008-04-14 12:27:44.000000000 -0700
@@ -1221,20 +1221,6 @@
 			goto done;
 		}
 
-	} else {
-		/* Initial request.  Initialize state. */
-#if 0
-		if ( op->o_conn->c_pagedresults_state.ps_cookie != 0 ) {
-			/* There's another pagedResults control on the
-			 * same connection; reject new pagedResults controls 
-			 * (allowed by RFC2696) */
-			rs->sr_text = "paged results cookie unavailable; try later";
-			rc = LDAP_UNWILLING_TO_PERFORM;
-			goto done;
-		}
-#endif
-		ps->ps_cookie = 0;
-		ps->ps_count = 0;
 	}
 
 done:;
diff -dur openldap-2.3.41/servers/slapd/back-ldap/bind.c openldap-2.3.42/servers/slapd/back-ldap/bind.c
--- openldap-2.3.41/servers/slapd/back-ldap/bind.c	2008-02-11 15:24:20.000000000 -0800
+++ openldap-2.3.42/servers/slapd/back-ldap/bind.c	2008-04-14 12:29:12.000000000 -0700
@@ -1311,15 +1311,26 @@
 
 		lutil_sasl_freedefs( defaults );
 
-		rs->sr_err = slap_map_api2result( rs );
-		if ( rs->sr_err != LDAP_SUCCESS ) {
+		switch ( rs->sr_err ) {
+		case LDAP_SUCCESS:
+			LDAP_BACK_CONN_ISBOUND_SET( lc );
+			break;
+
+		case LDAP_LOCAL_ERROR:
+			/* list client API error codes that require
+			 * to taint the connection */
+			/* FIXME: should actually retry? */
+			LDAP_BACK_CONN_TAINTED_SET( lc );
+
+			/* fallthru */
+
+		default:
 			LDAP_BACK_CONN_ISBOUND_CLEAR( lc );
+			rs->sr_err = slap_map_api2result( rs );
 			if ( sendok & LDAP_BACK_SENDERR ) {
 				send_ldap_result( op, rs );
 			}
-
-		} else {
-			LDAP_BACK_CONN_ISBOUND_SET( lc );
+			break;
 		}
 
 		if ( LDAP_BACK_QUARANTINE( li ) ) {
@@ -1999,15 +2010,26 @@
 				LDAP_SASL_QUIET, lutil_sasl_interact,
 				defaults );
 
-		rs->sr_err = slap_map_api2result( rs );
-		if ( rs->sr_err != LDAP_SUCCESS ) {
+		switch ( rs->sr_err ) {
+		case LDAP_SUCCESS:
+			LDAP_BACK_CONN_ISBOUND_SET( lc );
+			break;
+
+		case LDAP_LOCAL_ERROR:
+			/* list client API error codes that require
+			 * to taint the connection */
+			/* FIXME: should actually retry? */
+			LDAP_BACK_CONN_TAINTED_SET( lc );
+
+			/* fallthru */
+
+		default:
 			LDAP_BACK_CONN_ISBOUND_CLEAR( lc );
+			rs->sr_err = slap_map_api2result( rs );
 			if ( sendok & LDAP_BACK_SENDERR ) {
 				send_ldap_result( op, rs );
 			}
-
-		} else {
-			LDAP_BACK_CONN_ISBOUND_SET( lc );
+			break;
 		}
 
 		lutil_sasl_freedefs( defaults );
diff -dur openldap-2.3.41/servers/slapd/connection.c openldap-2.3.42/servers/slapd/connection.c
--- openldap-2.3.41/servers/slapd/connection.c	2008-02-11 15:24:15.000000000 -0800
+++ openldap-2.3.42/servers/slapd/connection.c	2008-04-21 11:51:48.000000000 -0700
@@ -1712,6 +1712,9 @@
 {
 	Operation *op;
 
+	if( conn->c_writewaiter )
+		return 0;
+
 	if( conn->c_conn_state == SLAP_C_CLOSING ) {
 		ber_socket_t	sd;
 		ber_sockbuf_ctrl( conn->c_sb, LBER_SB_OPT_GET_FD, &sd );
@@ -1723,7 +1726,7 @@
 		return 0;
 	}
 
-	if( conn->c_conn_state != SLAP_C_ACTIVE || conn->c_writewaiter ) {
+	if( conn->c_conn_state != SLAP_C_ACTIVE ) {
 		/* other states need different handling */
 		return 0;
 	}
diff -dur openldap-2.3.41/servers/slapd/controls.c openldap-2.3.42/servers/slapd/controls.c
--- openldap-2.3.41/servers/slapd/controls.c	2008-02-11 15:24:15.000000000 -0800
+++ openldap-2.3.42/servers/slapd/controls.c	2008-04-14 12:27:44.000000000 -0700
@@ -1001,6 +1001,10 @@
 	*ps = op->o_conn->c_pagedresults_state;
 	ps->ps_size = size;
 	op->o_pagedresults_state = ps;
+	if ( !cookie.bv_len ) {
+		ps->ps_count = 0;
+		ps->ps_cookie = 0;
+	}
 
 	/* NOTE: according to RFC 2696 3.:
 
diff -dur openldap-2.3.41/servers/slapd/overlays/accesslog.c openldap-2.3.42/servers/slapd/overlays/accesslog.c
--- openldap-2.3.41/servers/slapd/overlays/accesslog.c	2008-02-12 12:37:20.000000000 -0800
+++ openldap-2.3.42/servers/slapd/overlays/accesslog.c	2008-05-01 13:36:54.000000000 -0700
@@ -915,7 +915,7 @@
 		old = li->li_old;
 		li->li_old = NULL;
 		/* Disarm mod_cleanup */
-		for ( cb = op->o_callback->sc_next; cb; cb = cb->sc_next ) {
+		for ( cb = op->o_callback; cb; cb = cb->sc_next ) {
 			if ( cb->sc_private == (void *)on ) {
 				cb->sc_private = NULL;
 				break;
Only in openldap-2.3.42/servers/slapd/overlays: CVS
diff -dur openldap-2.3.41/servers/slapd/overlays/syncprov.c openldap-2.3.42/servers/slapd/overlays/syncprov.c
--- openldap-2.3.41/servers/slapd/overlays/syncprov.c	2008-02-11 15:24:25.000000000 -0800
+++ openldap-2.3.42/servers/slapd/overlays/syncprov.c	2008-05-13 13:09:15.000000000 -0700
@@ -1856,6 +1860,7 @@
 {
 	searchstate *ss = op->o_callback->sc_private;
 	slap_overinst *on = ss->ss_on;
+	syncprov_info_t *si = (syncprov_info_t *)on->on_bi.bi_private;
 	sync_control *srs = op->o_controls[slap_cids.sc_LDAPsync];
 
 	if ( rs->sr_type == REP_SEARCH || rs->sr_type == REP_SEARCHREF ) {
@@ -1898,8 +1903,16 @@
 		rs->sr_ctrls = op->o_tmpalloc( sizeof(LDAPControl *)*2,
 			op->o_tmpmemctx );
 		rs->sr_ctrls[1] = NULL;
-		rs->sr_err = syncprov_state_ctrl( op, rs, rs->sr_entry,
-			LDAP_SYNC_ADD, rs->sr_ctrls, 0, 0, NULL );
+		/* If we're in delta-sync mode, always send a cookie */
+		if ( si->si_nopres && si->si_usehint && a ) {
+			struct berval cookie;
+			slap_compose_sync_cookie( op, &cookie, a->a_nvals, srs->sr_state.rid );
+			rs->sr_err = syncprov_state_ctrl( op, rs, rs->sr_entry,
+				LDAP_SYNC_ADD, rs->sr_ctrls, 0, 1, &cookie );
+		} else {
+			rs->sr_err = syncprov_state_ctrl( op, rs, rs->sr_entry,
+				LDAP_SYNC_ADD, rs->sr_ctrls, 0, 0, NULL );
+		}
 	} else if ( rs->sr_type == REP_RESULT && rs->sr_err == LDAP_SUCCESS ) {
 		struct berval cookie;
 
Only in openldap-2.3.42/servers/slapd/schema: CVS
diff -dur openldap-2.3.41/servers/slapd/schema_check.c openldap-2.3.42/servers/slapd/schema_check.c
--- openldap-2.3.41/servers/slapd/schema_check.c	2008-02-11 15:24:17.000000000 -0800
+++ openldap-2.3.42/servers/slapd/schema_check.c	2008-04-21 09:55:40.000000000 -0700
@@ -328,11 +328,11 @@
 				ObjectClass *xc = NULL;
 				for( j=0; aoc->a_vals[j].bv_val; j++ ) {
 					if( i != j ) {
-						xc = oc_bvfind( &aoc->a_vals[i] );
+						xc = oc_bvfind( &aoc->a_vals[j] );
 						if( xc == NULL ) {
 							snprintf( textbuf, textlen, 
 								"unrecognized objectClass '%s'",
-								aoc->a_vals[i].bv_val );
+								aoc->a_vals[j].bv_val );
 
 							Debug( LDAP_DEBUG_ANY,
 								"entry_check_schema(%s): %s\n",
@@ -356,8 +356,8 @@
 					}
 				}
 
-				if( xc == NULL ) {
-					snprintf( textbuf, textlen, "instanstantiation of "
+				if( xc != NULL ) {
+					snprintf( textbuf, textlen, "instantiation of "
 						"abstract objectClass '%s' not allowed",
 						aoc->a_vals[i].bv_val );
 
diff -dur openldap-2.3.41/servers/slapd/syncrepl.c openldap-2.3.42/servers/slapd/syncrepl.c
--- openldap-2.3.41/servers/slapd/syncrepl.c	2008-02-13 10:06:05.000000000 -0800
+++ openldap-2.3.42/servers/slapd/syncrepl.c	2008-04-16 08:52:42.000000000 -0700
@@ -722,10 +722,17 @@
 					if (( rc = syncrepl_message_to_op( si, op, msg )) == LDAP_SUCCESS &&
 						!BER_BVISNULL( &syncCookie.ctxcsn ) ) {
 						syncrepl_updateCookie( si, op, psub, &syncCookie );
-					} else if ( rc == LDAP_NO_SUCH_OBJECT ) {
-						rc = LDAP_SYNC_REFRESH_REQUIRED;
-						si->si_logstate = SYNCLOG_FALLBACK;
-						ldap_abandon_ext( si->si_ld, si->si_msgid, NULL, NULL );
+					} else switch ( rc ) {
+						case LDAP_ALREADY_EXISTS:
+						case LDAP_NO_SUCH_OBJECT:
+						case LDAP_NO_SUCH_ATTRIBUTE:
+						case LDAP_TYPE_OR_VALUE_EXISTS:
+							rc = LDAP_SYNC_REFRESH_REQUIRED;
+							si->si_logstate = SYNCLOG_FALLBACK;
+							ldap_abandon_ext( si->si_ld, si->si_msgid, NULL, NULL );
+							break;
+						default:
+							break;
 					}
 				} else if (( rc = syncrepl_message_to_entry( si, op, msg,
 					&modlist, &entry, syncstate )) == LDAP_SUCCESS ) {
