--- openldap-2.4.14/servers/slapd/syncrepl.c	10 Feb 2009 14:13:31 -0000	1.443
+++ openldap-2.4.14/servers/slapd/syncrepl.c	11 Feb 2009 21:00:00 -0000	1.444
@@ -2876,6 +2876,9 @@ syncrepl_updateCookie(
 	Backend *be = op->o_bd;
 	Modifications mod;
 	struct berval first = BER_BVNULL;
+#ifdef CHECK_CSN
+	Syntax *syn = slap_schema.si_ad_contextCSN->ad_type->sat_syntax;
+#endif
 
 	int rc, i, j;
 	ber_len_t len;
@@ -2892,6 +2895,15 @@ syncrepl_updateCookie(
 
 	ldap_pvt_thread_mutex_lock( &si->si_cookieState->cs_mutex );
 
+#ifdef CHECK_CSN
+	for ( i=0; i<syncCookie->numcsns; i++ ) {
+		assert( !syn->ssyn_validate( syn, syncCookie->ctxcsn+i ));
+	}
+	for ( i=0; i<si->si_cookieState->cs_num; i++ ) {
+		assert( !syn->ssyn_validate( syn, si->si_cookieState->cs_vals+i ));
+	}
+#endif
+
 	/* clone the cookieState CSNs so we can Replace the whole thing */
 	mod.sml_numvals = si->si_cookieState->cs_num;
 	mod.sml_values = op->o_tmpalloc(( mod.sml_numvals+1 )*sizeof(struct berval), op->o_tmpmemctx );
@@ -2994,6 +3006,12 @@ syncrepl_updateCookie(
 	if ( mod.sml_next ) slap_mods_free( mod.sml_next, 1 );
 	op->o_tmpfree( mod.sml_values, op->o_tmpmemctx );
 
+#ifdef CHECK_CSN
+	for ( i=0; i<si->si_cookieState->cs_num; i++ ) {
+		assert( !syn->ssyn_validate( syn, si->si_cookieState->cs_vals+i ));
+	}
+#endif
+
 	return rc;
 }
 
--- openldap-2.4.14/servers/slapd/overlays/syncprov.c	28 Jan 2009 01:03:07 -0000	1.256
+++ openldap-2.4.14/servers/slapd/overlays/syncprov.c	15 Feb 2009 23:12:38 -0000	1.261
@@ -28,6 +28,10 @@
 #include "config.h"
 #include "ldap_rq.h"
 
+#ifdef LDAP_DEVEL
+#define	CHECK_CSN	1
+#endif
+
 /* A modify request on a particular entry */
 typedef struct modinst {
 	struct modinst *mi_next;
@@ -704,6 +708,10 @@ again:
 	switch( mode ) {
 	case FIND_MAXCSN:
 		if ( ber_bvcmp( &si->si_ctxcsn[maxid], &maxcsn )) {
+#ifdef CHECK_CSN
+			Syntax *syn = slap_schema.si_ad_contextCSN->ad_type->sat_syntax;
+			assert( !syn->ssyn_validate( syn, &maxcsn ));
+#endif
 			ber_bvreplace( &si->si_ctxcsn[maxid], &maxcsn );
 			si->si_numops++;	/* ensure a checkpoint */
 		}
@@ -1339,7 +1347,14 @@ syncprov_checkpoint( Operation *op, Slap
 	SlapReply rsm = { 0 };
 	slap_callback cb = {0};
 	BackendDB be;
+#ifdef CHECK_CSN
+	Syntax *syn = slap_schema.si_ad_contextCSN->ad_type->sat_syntax;
 
+	int i;
+	for ( i=0; i<si->si_numcsns; i++ ) {
+		assert( !syn->ssyn_validate( syn, si->si_ctxcsn+i ));
+	}
+#endif
 	mod.sml_numvals = si->si_numcsns;
 	mod.sml_values = si->si_ctxcsn;
 	mod.sml_nvalues = NULL;
@@ -1367,6 +1382,11 @@ syncprov_checkpoint( Operation *op, Slap
 	if ( mod.sml_next != NULL ) {
 		slap_mods_free( mod.sml_next, 1 );
 	}
+#ifdef CHECK_CSN
+	for ( i=0; i<si->si_numcsns; i++ ) {
+		assert( !syn->ssyn_validate( syn, si->si_ctxcsn+i ));
+	}
+#endif
 }
 
 static void
@@ -1608,15 +1628,17 @@ syncprov_op_response( Operation *op, Sla
 
 	if ( rs->sr_err == LDAP_SUCCESS )
 	{
-		struct berval maxcsn = BER_BVNULL;
+		struct berval maxcsn;
 		char cbuf[LDAP_LUTIL_CSNSTR_BUFSIZE];
 		int do_check = 0, have_psearches, foundit;
 
 		/* Update our context CSN */
 		cbuf[0] = '\0';
+		maxcsn.bv_val = cbuf;
+		maxcsn.bv_len = sizeof(cbuf);
 		ldap_pvt_thread_rdwr_wlock( &si->si_csn_rwlock );
 		slap_get_commit_csn( op, &maxcsn, &foundit );
-		if ( BER_BVISNULL( &maxcsn ) && SLAP_GLUE_SUBORDINATE( op->o_bd )) {
+		if ( BER_BVISEMPTY( &maxcsn ) && SLAP_GLUE_SUBORDINATE( op->o_bd )) {
 			/* syncrepl queues the CSN values in the db where
 			 * it is configured , not where the changes are made.
 			 * So look for a value in the glue db if we didn't
@@ -1624,12 +1646,17 @@ syncprov_op_response( Operation *op, Sla
 			 */
 			BackendDB *be = op->o_bd;
 			op->o_bd = select_backend( &be->be_nsuffix[0], 1);
+			maxcsn.bv_val = cbuf;
+			maxcsn.bv_len = sizeof(cbuf);
 			slap_get_commit_csn( op, &maxcsn, &foundit );
 			op->o_bd = be;
 		}
-		if ( !BER_BVISNULL( &maxcsn ) ) {
+		if ( !BER_BVISEMPTY( &maxcsn ) ) {
 			int i, sid;
-			strcpy( cbuf, maxcsn.bv_val );
+#ifdef CHECK_CSN
+			Syntax *syn = slap_schema.si_ad_contextCSN->ad_type->sat_syntax;
+			assert( !syn->ssyn_validate( syn, &maxcsn ));
+#endif
 			sid = slap_parse_csn_sid( &maxcsn );
 			for ( i=0; i<si->si_numcsns; i++ ) {
 				if ( sid == si->si_sids[i] ) {
@@ -1685,8 +1712,7 @@ syncprov_op_response( Operation *op, Sla
 
 		/* only update consumer ctx if this is the greatest csn */
 		if ( bvmatch( &maxcsn, &op->o_csn )) {
-			opc->sctxcsn.bv_len = maxcsn.bv_len;
-			opc->sctxcsn.bv_val = cbuf;
+			opc->sctxcsn = maxcsn;
 		}
 
 		/* Handle any persistent searches */
@@ -1750,6 +1776,7 @@ syncprov_op_compare( Operation *op, Slap
 
 		a.a_vals = si->si_ctxcsn;
 		a.a_nvals = a.a_vals;
+		a.a_numvals = si->si_numcsns;
 
 		rs->sr_err = access_allowed( op, &e, op->oq_compare.rs_ava->aa_desc,
 			&op->oq_compare.rs_ava->aa_value, ACL_COMPARE, NULL );
--- openldap-2.4.14/servers/slapd/ctxcsn.c	21 Jan 2009 23:40:26 -0000	1.52
+++ openldap-2.4.14/servers/slapd/ctxcsn.c	15 Feb 2009 23:12:38 -0000	1.53
@@ -30,6 +30,7 @@ const struct berval slap_ldapsync_bv = B
 const struct berval slap_ldapsync_cn_bv = BER_BVC("cn=ldapsync");
 int slap_serverID;
 
+/* maxcsn->bv_val must point to a char buf[LDAP_LUTIL_CSNSTR_BUFSIZE] */
 void
 slap_get_commit_csn(
 	Operation *op,
@@ -41,7 +42,8 @@ slap_get_commit_csn(
 	BackendDB *be = op->o_bd->bd_self;
 
 	if ( maxcsn ) {
-		BER_BVZERO( maxcsn );
+		assert( maxcsn->bv_val != NULL );
+		assert( maxcsn->bv_len >= LDAP_LUTIL_CSNSTR_BUFSIZE );
 	}
 	if ( foundit ) {
 		*foundit = 0;
@@ -62,7 +64,17 @@ slap_get_commit_csn(
 		if ( csne->ce_state == SLAP_CSN_PENDING ) break;
 	}
 
-	if ( committed_csne && maxcsn ) *maxcsn = committed_csne->ce_csn;
+	if ( maxcsn ) {
+		if ( committed_csne ) {
+			if ( committed_csne->ce_csn.bv_len < maxcsn->bv_len )
+				maxcsn->bv_len = committed_csne->ce_csn.bv_len;
+			AC_MEMCPY( maxcsn->bv_val, committed_csne->ce_csn.bv_val,
+				maxcsn->bv_len+1 );
+		} else {
+			maxcsn->bv_len = 0;
+			maxcsn->bv_val[0] = 0;
+		}
+	}
 	ldap_pvt_thread_mutex_unlock( &be->be_pcl_mutex );
 }
 
