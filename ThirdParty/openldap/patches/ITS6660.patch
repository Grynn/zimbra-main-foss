--- openldap-2.4.23/servers/slapd/operation.c.orig	2010-09-28 15:39:57.825257979 -0700
+++ openldap-2.4.23/servers/slapd/operation.c	2010-09-28 15:40:21.845256280 -0700
@@ -116,6 +116,11 @@
 		BER_BVZERO( &op->o_csn );
 	}
 
+	if ( op->o_pagedresults_state != NULL ) {
+		op->o_tmpfree( op->o_pagedresults_state, op->o_tmpmemctx );
+		op->o_pagedresults_state = NULL;
+	}
+
 	opbuf = (OperationBuffer *) op;
 	memset( opbuf, 0, sizeof(*opbuf) );
 	op->o_hdr = &opbuf->ob_hdr;
--- openldap-2.4.23/servers/slapd/back-bdb/proto-bdb.h	1 Jul 2010 14:38:32 -0000	1.168
+++ openldap-2.4.23/servers/slapd/back-bdb/proto-bdb.h	22 Dec 2010 23:16:19 -0000	1.169
@@ -547,6 +547,7 @@ int bdb_cache_find_ndn(
 #define	ID_LOCKED	1
 #define	ID_NOCACHE	2
 #define	ID_NOENTRY	4
+#define	ID_CHKPURGE	8
 int bdb_cache_find_id(
 	Operation *op,
 	DB_TXN	*tid,
--- openldap-2.4.23/servers/slapd/back-bdb/cache.c	20 Dec 2010 09:57:06 -0000	1.219
+++ openldap-2.4.23/servers/slapd/back-bdb/cache.c	23 Dec 2010 03:40:57 -0000	1.221
@@ -265,9 +265,8 @@ bdb_cache_return_entry_rw( struct bdb_in
 	int free = 0;
 
 	ei = e->e_private;
-	if ( ei &&
-		( ei->bei_state & CACHE_ENTRY_NOT_CACHED ) &&
-		( bdb_cache_entryinfo_trylock( ei ) == 0 )) {
+	if ( ei && ( ei->bei_state & CACHE_ENTRY_NOT_CACHED )) {
+		bdb_cache_entryinfo_lock( ei );
 		if ( ei->bei_state & CACHE_ENTRY_NOT_CACHED ) {
 			/* Releasing the entry can only be done when
 			 * we know that nobody else is using it, i.e we
@@ -968,6 +967,7 @@ load1:
 			if ( !(*eip)->bei_e && !((*eip)->bei_state & CACHE_ENTRY_LOADING)) {
 				load = 1;
 				(*eip)->bei_state |= CACHE_ENTRY_LOADING;
+				flag |= ID_CHKPURGE;
 			}
 
 			if ( !load ) {
@@ -976,12 +976,9 @@ load1:
 				 * another thread is currently loading it.
 				 */
 				if ( (*eip)->bei_state & CACHE_ENTRY_NOT_CACHED ) {
-					(*eip)->bei_state &= ~CACHE_ENTRY_NOT_CACHED;
-					ldap_pvt_thread_mutex_lock( &bdb->bi_cache.c_count_mutex );
-					++bdb->bi_cache.c_cursize;
-					ldap_pvt_thread_mutex_unlock( &bdb->bi_cache.c_count_mutex );
+					(*eip)->bei_state ^= CACHE_ENTRY_NOT_CACHED;
+					flag |= ID_CHKPURGE;
 				}
-				flag &= ~ID_NOCACHE;
 			}
 
 			if ( flag & ID_LOCKED ) {
@@ -1007,21 +1004,24 @@ load1:
 							ldap_pvt_thread_yield();
 						bdb_fix_dn( ep, 0 );
 #endif
+						bdb_cache_entryinfo_lock( *eip );
+
 						(*eip)->bei_e = ep;
 #ifdef SLAP_ZONE_ALLOC
 						(*eip)->bei_zseq = *((ber_len_t *)ep - 2);
 #endif
 						ep = NULL;
-						bdb_cache_lru_link( bdb, *eip );
-						if (( flag & ID_NOCACHE ) &&
-							( bdb_cache_entryinfo_trylock( *eip ) == 0 )) {
+						if ( flag & ID_NOCACHE ) {
 							/* Set the cached state only if no other thread
 							 * found the info while we were loading the entry.
 							 */
-							if ( (*eip)->bei_finders == 1 )
+							if ( (*eip)->bei_finders == 1 ) {
 								(*eip)->bei_state |= CACHE_ENTRY_NOT_CACHED;
-							bdb_cache_entryinfo_unlock( *eip );
+								flag ^= ID_CHKPURGE;
+							}
 						}
+						bdb_cache_entryinfo_unlock( *eip );
+						bdb_cache_lru_link( bdb, *eip );
 					}
 					if ( rc == 0 ) {
 						/* If we succeeded, downgrade back to a readlock. */
@@ -1077,9 +1077,9 @@ load1:
 	if ( rc == 0 ) {
 		int purge = 0;
 
-		if (( load && !( flag & ID_NOCACHE )) || bdb->bi_cache.c_eimax ) {
+		if (( flag & ID_CHKPURGE ) || bdb->bi_cache.c_eimax ) {
 			ldap_pvt_thread_mutex_lock( &bdb->bi_cache.c_count_mutex );
-			if ( load && !( flag & ID_NOCACHE )) {
+			if ( flag & ID_CHKPURGE ) {
 				bdb->bi_cache.c_cursize++;
 				if ( !bdb->bi_cache.c_purging && bdb->bi_cache.c_cursize > bdb->bi_cache.c_maxsize ) {
 					purge = 1;
@@ -1533,6 +1533,36 @@ bdb_cache_release_all( Cache *cache )
 }
 
 #ifdef LDAP_DEBUG
+static void
+bdb_lru_count( Cache *cache )
+{
+	EntryInfo	*e;
+	int ei = 0, ent = 0, nc = 0;
+
+	for ( e = cache->c_lrutail; ; ) {
+		ei++;
+		if ( e->bei_e ) {
+			ent++;
+			if ( e->bei_state & CACHE_ENTRY_NOT_CACHED )
+				nc++;
+			fprintf( stderr, "ei %d entry %p dn %s\n", ei, e->bei_e, e->bei_e->e_name.bv_val );
+		}
+		e = e->bei_lrunext;
+		if ( e == cache->c_lrutail )
+			break;
+	}
+	fprintf( stderr, "counted %d entryInfos and %d entries, %d notcached\n",
+		ei, ent, nc );
+	ei = 0;
+	for ( e = cache->c_lrutail; ; ) {
+		ei++;
+		e = e->bei_lruprev;
+		if ( e == cache->c_lrutail )
+			break;
+	}
+	fprintf( stderr, "counted %d entryInfos (on lruprev)\n", ei );
+}
+
 #ifdef SLAPD_UNUSED
 static void
 bdb_lru_print( Cache *cache )
