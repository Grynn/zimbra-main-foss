--- openldap-2.4.17/libraries/liblber/bprint.c	2008-02-12 00:26:41.000000000 +0100
+++ openldap-2.4.17/libraries/liblber/bprint.c	2009-07-23 11:14:56.000000000 +0200
@@ -283,12 +283,5 @@
 	Seqorset *sos )
 {
-	assert( sos != NULL );
-
-	if ( !ber_log_check( errlvl, loglvl )) {
-		return 0;
-	}
-
-	ber_sos_dump( sos );
-	return 1;
+	return 0;
 }
 
@@ -297,26 +290,3 @@
 	Seqorset *sos )
 {
-	char buf[132];
-
-	assert( sos != NULL );
-
-	(*ber_pvt_log_print)( "*** sos dump ***\n" );
-
-	while ( sos != NULL ) {
-		sprintf( buf, "ber_sos_dump: clen %ld first %p ptr %p\n",
-		    (long) sos->sos_clen,
-			sos->sos_first,
-			sos->sos_ptr );
-		(*ber_pvt_log_print)( buf );
-
-		sprintf( buf, "              current len %ld contents:\n",
-		    (long) (sos->sos_ptr - sos->sos_first) );
-		(*ber_pvt_log_print)( buf );
-
-		ber_bprint( sos->sos_first, sos->sos_ptr - sos->sos_first );
-
-		sos = sos->sos_next;
-	}
-
-	(*ber_pvt_log_print)( "*** end dump ***\n" );
 }
--- openldap-2.4.17/libraries/liblber/decode.c	2008-09-03 01:54:37.000000000 +0200
+++ openldap-2.4.17/libraries/liblber/decode.c	2009-07-18 15:57:02.000000000 +0200
@@ -41,8 +41,4 @@
 #include "lber-int.h"
 
-static ber_len_t ber_getnint LDAP_P((
-	BerElement *ber,
-	ber_int_t *num,
-	ber_len_t len ));
 
 /* out->bv_len should be the buffer size on input */
@@ -147,7 +143,5 @@
 	unsigned char netlen[sizeof(ber_len_t)];
 
-	assert( ber != NULL );
 	assert( len != NULL );
-	assert( LBER_VALID( ber ) );
 
 	/*
@@ -241,7 +235,5 @@
 	unsigned char buf[sizeof(ber_int_t)];
 
-	assert( ber != NULL );
 	assert( num != NULL );
-	assert( LBER_VALID( ber ) );
 
 	/*
@@ -289,7 +281,4 @@
 	ber_len_t	len;
 
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
-
 	if ( (tag = ber_skip_tag( ber, &len )) == LBER_DEFAULT ) {
 		return LBER_DEFAULT;
@@ -320,7 +309,4 @@
 	ber_tag_t	tag;
 
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
-
 	if ( (tag = ber_skip_tag( ber, &datalen )) == LBER_DEFAULT ) {
 		return LBER_DEFAULT;
@@ -488,9 +474,6 @@
 	ber_tag_t	tag;
 
-	assert( ber != NULL );
 	assert( bv != NULL );
 
-	assert( LBER_VALID( ber ) );
-
 	if ( (tag = ber_skip_tag( ber, &bv->bv_len )) == LBER_DEFAULT ) {
 		bv->bv_val = NULL;
@@ -532,9 +515,6 @@
 	ber_tag_t	tag;
 
-	assert( ber != NULL );
 	assert( bv != NULL );
 
-	assert( LBER_VALID( ber ) );
-
 	if ( (tag = ber_skip_tag( ber, &bv->bv_len )) == LBER_DEFAULT ) {
 		bv->bv_val = NULL;
@@ -637,10 +617,7 @@
 	unsigned char	unusedbits;
 
-	assert( ber != NULL );
 	assert( buf != NULL );
 	assert( blen != NULL );
 
-	assert( LBER_VALID( ber ) );
-
 	if ( (tag = ber_skip_tag( ber, &datalen )) == LBER_DEFAULT ) {
 		*buf = NULL;
@@ -677,7 +654,4 @@
 	ber_tag_t	tag;
 
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
-
 	if ( (tag = ber_skip_tag( ber, &len )) == LBER_DEFAULT ) {
 		return LBER_DEFAULT;
@@ -700,9 +674,6 @@
 	ber_tag_t	rc;
 
-	assert( ber != NULL );
 	assert( boolval != NULL );
 
-	assert( LBER_VALID( ber ) );
-
 	rc = ber_get_int( ber, &longbool );
 	*boolval = longbool;
@@ -717,6 +688,4 @@
 	char **last )
 {
-	assert( ber != NULL );
-	assert( len != NULL );
 	assert( last != NULL );
 
--- openldap-2.4.17/libraries/liblber/encode.c	2008-02-12 00:26:41.000000000 +0100
+++ openldap-2.4.17/libraries/liblber/encode.c	2009-07-24 07:31:54.000000000 +0200
@@ -32,4 +32,5 @@
 
 #include <ctype.h>
+#include <limits.h>
 #include <stdio.h>
 
@@ -42,139 +43,50 @@
 #include "lber-int.h"
 
-static int ber_put_len LDAP_P((
-	BerElement *ber,
-	ber_len_t len,
-	int nosos ));
-
-static int ber_start_seqorset LDAP_P((
-	BerElement *ber,
-	ber_tag_t tag ));
+#define OCTET_SIZE(type) ((ber_len_t) (sizeof(type)*CHAR_BIT + 7) / 8)
+#define TAGBUF_SIZE OCTET_SIZE(ber_tag_t)
+#define LENBUF_SIZE (1 + OCTET_SIZE(ber_len_t))
+#define HEADER_SIZE (TAGBUF_SIZE + LENBUF_SIZE)
 
-static int ber_put_seqorset LDAP_P(( BerElement *ber ));
-
-static int ber_put_int_or_enum LDAP_P((
-	BerElement *ber,
-	ber_int_t num,
-	ber_tag_t tag ));
+/* We support BER element length of max 0xffffffff, except some
+ * functions return an int length so that is their max.  Duh.
+ */
+#define MAXINT_BERSIZE \
+	(INT_MAX>0xffffffffUL ? (ber_len_t) 0xffffffffUL : INT_MAX-HEADER_SIZE)
 
-#define	BER_TOP_BYTE(type)	(sizeof(type)-1)
-#define	BER_TOP_MASK(type)	((type)0xffU << (BER_TOP_BYTE(type)*8))
 
-static int
-ber_calc_taglen( ber_tag_t tag )
+/* Prepend tag to ptr, which points to the end of a tag buffer */
+static unsigned char *
+ber_prepend_tag( unsigned char *ptr, ber_tag_t tag )
 {
-	int	i = BER_TOP_BYTE(ber_tag_t);
-	ber_tag_t	mask = BER_TOP_MASK(ber_tag_t);
-
-	/* find the first non-all-zero byte in the tag */
-	for ( ; i > 0; i-- ) {
-		/* not all zero */
-		if ( tag & mask ) break;
-		mask >>= 8;
-	}
+	do {
+		*--ptr = (unsigned char) tag & 0xffU;
+	} while ( (tag >>= 8) != 0 );
 
-	return i + 1;
+	return ptr;
 }
 
-static int
-ber_put_tag(
-	BerElement	*ber,
-	ber_tag_t tag,
-	int nosos )
-{
-	int rc;
-	int taglen;
-	int	i;
-	unsigned char nettag[sizeof(ber_tag_t)];
-
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
-
-	taglen = ber_calc_taglen( tag );
-
-	for( i=taglen-1; i>=0; i-- ) {
-		nettag[i] = (unsigned char)(tag & 0xffU);
-		tag >>= 8;
-	}
-
-	rc = ber_write( ber, (char *) nettag, taglen, nosos );
-
-	return rc;
-}
-
-static ber_len_t
-ber_calc_lenlen( ber_len_t len )
+/* Prepend ber length to ptr, which points to the end of a length buffer */
+static unsigned char *
+ber_prepend_len( unsigned char *ptr, ber_len_t len )
 {
 	/*
 	 * short len if it's less than 128 - one byte giving the len,
 	 * with bit 8 0.
-	 */
-
-	if ( len <= (ber_len_t) 0x7FU ) return 1;
-
-	/*
 	 * long len otherwise - one byte with bit 8 set, giving the
 	 * length of the length, followed by the length itself.
 	 */
 
-	if ( len <= (ber_len_t) 0xffU ) return 2;
-	if ( len <= (ber_len_t) 0xffffU ) return 3;
-	if ( len <= (ber_len_t) 0xffffffU ) return 4;
-
-	return 5;
-}
-
-static int
-ber_put_len( BerElement *ber, ber_len_t len, int nosos )
-{
-	int rc;
-	int		i,j;
-	char		lenlen;
-	ber_len_t	mask;
-	unsigned char netlen[sizeof(ber_len_t)];
-
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
-
-	/*
-	 * short len if it's less than 128 - one byte giving the len,
-	 * with bit 8 0.
-	 */
-
-	if ( len <= 127 ) {
-		char length_byte = (char) len;
-		return ber_write( ber, &length_byte, 1, nosos );
-	}
+	*--ptr = (unsigned char) len & 0xffU;
 
-	/*
-	 * long len otherwise - one byte with bit 8 set, giving the
-	 * length of the length, followed by the length itself.
-	 */
+	if ( len >= 0x80 ) {
+		unsigned char *endptr = ptr--;
 
-	/* find the first non-all-zero byte */
-	i = BER_TOP_BYTE(ber_len_t);
-	mask = BER_TOP_MASK(ber_len_t);
-	for ( ; i > 0; i-- ) {
-		/* not all zero */
-		if ( len & mask ) break;
-		mask >>= 8;
-	}
-	lenlen = (unsigned char) ++i;
-	if ( lenlen > 4 ) return -1;
-
-	lenlen |= 0x80UL;
-
-	/* write the length of the length */
-	if ( ber_write( ber, &lenlen, 1, nosos ) != 1 ) return -1;
-
-	for( j=i-1; j>=0; j-- ) {
-		netlen[j] = (unsigned char)(len & 0xffU);
-		len >>= 8;
+		while ( (len >>= 8) != 0 ) {
+			*ptr-- = (unsigned char) len & 0xffU;
+		}
+		*ptr = (unsigned char) (endptr - ptr) + 0x80U;
 	}
 
-	/* write the length itself */
-	rc = ber_write( ber, (char *) netlen, i, nosos );
-
-	return rc == i ?  i+1 : -1;
+	return ptr;
 }
 
@@ -211,4 +123,5 @@
 		if ( ptr > inend ) return -1;
 
+		/* Write the OID component little-endian, then reverse it */
 		len = 0;
 		do {
@@ -242,62 +155,23 @@
 	ber_tag_t tag )
 {
-	int rc;
-	int	i, j, sign, taglen, lenlen;
-	ber_len_t	len;
-	ber_uint_t	unum, mask;
-	unsigned char netnum[sizeof(ber_uint_t)];
-
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
+	ber_uint_t unum;
+	unsigned char sign, data[HEADER_SIZE + OCTET_SIZE(ber_int_t)], *ptr;
 
-	sign = (num < 0);
+	sign = 0;
 	unum = num;	/* Bit fiddling should be done with unsigned values */
-
-	/*
-	 * high bit is set - look for first non-all-one byte
-	 * high bit is clear - look for first non-all-zero byte
-	 */
-	i = BER_TOP_BYTE(ber_int_t);
-	mask = BER_TOP_MASK(ber_uint_t);
-	for ( ; i > 0; i-- ) {
-		if ( sign ) {
-			/* not all ones */
-			if ( (unum & mask) != mask ) break;
-		} else {
-			/* not all zero */
-			if ( unum & mask ) break;
-		}
-		mask >>= 8;
-	}
-
-	/*
-	 * we now have the "leading byte".  if the high bit on this
-	 * byte matches the sign bit, we need to "back up" a byte.
-	 */
-	mask = (unum & ((ber_uint_t)0x80U << (i * 8)));
-	if ( (mask && !sign) || (sign && !mask) ) {
-		i++;
-	}
-
-	len = i + 1;
-
-	if ( (taglen = ber_put_tag( ber, tag, 0 )) == -1 ) {
-		return -1;
-	}
-
-	if ( (lenlen = ber_put_len( ber, len, 0 )) == -1 ) {
-		return -1;
+	if ( num < 0 ) {
+		sign = 0xffU;
+		unum = ~unum;
 	}
-	i++;
-
-	for( j=i-1; j>=0; j-- ) {
-		netnum[j] = (unsigned char)(unum & 0xffU);
-		unum >>= 8;
+	for ( ptr = &data[sizeof(data) - 1] ;; unum >>= 8 ) {
+		*ptr-- = (sign ^ (unsigned char) unum) & 0xffU;
+		if ( unum < 0x80 )	/* top bit at *ptr is sign bit */
+			break;
 	}
 
-	rc = ber_write( ber, (char *) netnum, i, 0 );
+	*ptr = (unsigned char) (&data[sizeof(data) - 1] - ptr); /* length */
+	ptr = ber_prepend_tag( ptr, tag );
 
-	/* length of tag + length + contents */
-	return rc == i ? taglen + lenlen + i : -1;
+	return ber_write( ber, (char *) ptr, &data[sizeof(data)] - ptr, 0 );
 }
 
@@ -308,7 +182,4 @@
 	ber_tag_t tag )
 {
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
-
 	if ( tag == LBER_DEFAULT ) {
 		tag = LBER_ENUMERATED;
@@ -324,7 +195,4 @@
 	ber_tag_t tag )
 {
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
-
 	if ( tag == LBER_DEFAULT ) {
 		tag = LBER_INTEGER;
@@ -341,10 +209,6 @@
 	ber_tag_t tag )
 {
-	int taglen, lenlen, rc;
-
-	assert( ber != NULL );
-	assert( str != NULL );
-
-	assert( LBER_VALID( ber ) );
+	int rc;
+	unsigned char header[HEADER_SIZE], *ptr;
 
 	if ( tag == LBER_DEFAULT ) {
@@ -352,14 +216,15 @@
 	}
 
-	if ( (taglen = ber_put_tag( ber, tag, 0 )) == -1 )
+	if ( len > MAXINT_BERSIZE ) {
 		return -1;
+	}
 
-	if ( (lenlen = ber_put_len( ber, len, 0 )) == -1 ||
-		(ber_len_t) ber_write( ber, str, len, 0 ) != len )
-	{
-		rc = -1;
-	} else {
+	ptr = ber_prepend_len( &header[sizeof(header)], len );
+	ptr = ber_prepend_tag( ptr, tag );
+
+	rc = ber_write( ber, (char *) ptr, &header[sizeof(header)] - ptr, 0 );
+	if ( rc >= 0 && ber_write( ber, str, len, 0 ) >= 0 ) {
 		/* return length of tag + length + contents */
-		rc = taglen + lenlen + len;
+		rc += (int) len;
 	}
 
@@ -373,7 +238,4 @@
 	ber_tag_t tag )
 {
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
-
 	if( bv == NULL || bv->bv_len == 0 ) {
 		return ber_put_ostring( ber, "", (ber_len_t) 0, tag );
@@ -389,9 +251,6 @@
 	ber_tag_t tag )
 {
-	assert( ber != NULL );
 	assert( str != NULL );
 
-	assert( LBER_VALID( ber ) );
-
 	return ber_put_ostring( ber, str, strlen( str ), tag );
 }
@@ -404,12 +263,7 @@
 	ber_tag_t tag )
 {
-	int				taglen, lenlen;
+	int rc;
 	ber_len_t		len;
-	unsigned char	unusedbits;
-
-	assert( ber != NULL );
-	assert( str != NULL );
-
-	assert( LBER_VALID( ber ) );
+	unsigned char	unusedbits, header[HEADER_SIZE + 1], *ptr;
 
 	if ( tag == LBER_DEFAULT ) {
@@ -417,24 +271,21 @@
 	}
 
-	if ( (taglen = ber_put_tag( ber, tag, 0 )) == -1 ) {
+	unusedbits = (unsigned char) -blen & 7;
+	len = blen / 8 + (unusedbits != 0); /* (blen+7)/8 without overflow */
+	if ( len >= MAXINT_BERSIZE ) {
 		return -1;
 	}
 
-	len = ( blen + 7 ) / 8;
-	unusedbits = (unsigned char) ((len * 8) - blen);
-	if ( (lenlen = ber_put_len( ber, len + 1, 0 )) == -1 ) {
-		return -1;
-	}
-
-	if ( ber_write( ber, (char *)&unusedbits, 1, 0 ) != 1 ) {
-		return -1;
-	}
+	header[sizeof(header) - 1] = unusedbits;
+	ptr = ber_prepend_len( &header[sizeof(header) - 1], len + 1 );
+	ptr = ber_prepend_tag( ptr, tag );
 
-	if ( (ber_len_t) ber_write( ber, str, len, 0 ) != len ) {
-		return -1;
+	rc = ber_write( ber, (char *) ptr, &header[sizeof(header)] - ptr, 0 );
+	if ( rc >= 0 && ber_write( ber, str, len, 0 ) >= 0 ) {
+		/* return length of tag + length + unused bit count + contents */
+		rc += (int) len;
 	}
 
-	/* return length of tag + length + unused bit count + contents */
-	return taglen + 1 + lenlen + len;
+	return rc;
 }
 
@@ -442,8 +293,5 @@
 ber_put_null( BerElement *ber, ber_tag_t tag )
 {
-	int	taglen;
-
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
+	unsigned char data[TAGBUF_SIZE + 1], *ptr;
 
 	if ( tag == LBER_DEFAULT ) {
@@ -451,13 +299,8 @@
 	}
 
-	if ( (taglen = ber_put_tag( ber, tag, 0 )) == -1 ) {
-		return -1;
-	}
-
-	if ( ber_put_len( ber, 0, 0 ) != 1 ) {
-		return -1;
-	}
+	data[sizeof(data) - 1] = 0;			/* length */
+	ptr = ber_prepend_tag( &data[sizeof(data) - 1], tag );
 
-	return taglen + 1;
+	return ber_write( ber, (char *) ptr, &data[sizeof(data)] - ptr, 0 );
 }
 
@@ -468,32 +311,30 @@
 	ber_tag_t tag )
 {
-	int				taglen;
-	unsigned char	c;
-
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
+	unsigned char data[TAGBUF_SIZE + 2], *ptr;
 
 	if ( tag == LBER_DEFAULT )
 		tag = LBER_BOOLEAN;
 
-	if ( (taglen = ber_put_tag( ber, tag, 0 )) == -1 ) {
-		return -1;
-	}
-
-	if ( ber_put_len( ber, 1, 0 ) != 1 ) {
-		return -1;
-	}
+	data[sizeof(data) - 2] = 1;			/* length */
+	data[sizeof(data) - 1] = boolval ? 0xff : 0;
+	ptr = ber_prepend_tag( &data[sizeof(data) - 2], tag );
 
-	c = boolval ? (unsigned char) ~0U : (unsigned char) 0U;
+	return ber_write( ber, (char *) ptr, &data[sizeof(data)] - ptr, 0 );
+}
 
-	if ( ber_write( ber, (char *) &c, 1, 0 ) != 1 ) {
-		return -1;
-	}
 
-	return taglen + 2;
-}
+#define MAX_LENLEN /* Max number of length octets, normally 5 */ \
+	(1 + (sizeof(ber_uint_t) < 4 ? 4 : sizeof(ber_uint_t)))
 
-#define FOUR_BYTE_LEN	5
+struct seqorset_header_s {
+	char tag[TAGBUF_SIZE + 1];	/* room for tag + len(len) */
+	union {
+		ber_uint_t offset;		/* enclosing seqence/set */
+		char padding[4];		/* in case sizeof(offset)<4 */
+	} next_sos;
+#	define SOS_TAG_END(header) ((unsigned char *) &(header).next_sos - 1)
+};
 
+/* Start a sequence or set */
 static int
 ber_start_seqorset(
@@ -501,29 +342,50 @@
 	ber_tag_t tag )
 {
-	Seqorset	*new;
+	/*
+	 * Write the tag and MAX_LENLEN octets reserved for length, to ber.
+	 * For now, length octets = (tag length, previous ber_sos_offset).
+	 */
+
+	struct seqorset_header_s header;
+	unsigned char	*headptr;
+	ber_len_t		taglen, headlen, offset;
+	char			**p;
 
 	assert( ber != NULL );
 	assert( LBER_VALID( ber ) );
 
-	new = (Seqorset *) ber_memcalloc_x( 1, sizeof(Seqorset), ber->ber_memctx );
+	if ( ber->ber_sos_ptr == NULL ) {
+		p = &ber->ber_ptr;
+		/*
+		 * TODO: ber->ber_sos_offset = alias for ber->ber_len.  Check
+		 * if ber_len is always zero here so this can be factored out.
+		 */
+		header.next_sos.offset = 0;
+	} else {
+		p = &ber->ber_sos_ptr;
+		header.next_sos.offset = ber->ber_sos_offset;
+	}
 
-	if ( new == NULL ) {
+	offset = *p - ber->ber_buf;
+	if ( offset >= (ber_uint_t) (ber_len_t) -HEADER_SIZE ) {
 		return -1;
 	}
 
-	new->sos_ber = ber;
-	if ( ber->ber_sos == NULL ) {
-		new->sos_first = ber->ber_ptr;
-	} else {
-		new->sos_first = ber->ber_sos->sos_ptr;
+	headptr = ber_prepend_tag( SOS_TAG_END(header), tag );
+	taglen = *SOS_TAG_END(header) = SOS_TAG_END(header) - headptr;
+	headlen = taglen + MAX_LENLEN;
+	if ( ber->ber_end - *p < (ptrdiff_t) headlen ) {
+		if ( ber_realloc( ber, headlen ) != 0 )
+			return -1;
 	}
 
-	/* Set aside room for a 4 byte length field */
-	new->sos_ptr = new->sos_first + ber_calc_taglen( tag ) + FOUR_BYTE_LEN;
-	new->sos_tag = tag;
-
-	new->sos_next = ber->ber_sos;
-	ber->ber_sos = new;
+	ber->ber_sos_ptr = *p;
+	ber->ber_sos_offset = offset + taglen;
+	(void) ber_write( ber, (char *) headptr, headlen, 0 );
 
+	/*
+	 * Do not return taglen + MAX_LENLEN here - then ber_put_seqorset()
+	 * should return lenlen - MAX_LENLEN + len, which can be < 0.
+	 */
 	return 0;
 }
@@ -532,7 +394,4 @@
 ber_start_seq( BerElement *ber, ber_tag_t tag )
 {
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
-
 	if ( tag == LBER_DEFAULT ) {
 		tag = LBER_SEQUENCE;
@@ -545,7 +404,4 @@
 ber_start_set( BerElement *ber, ber_tag_t tag )
 {
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
-
 	if ( tag == LBER_DEFAULT ) {
 		tag = LBER_SET;
@@ -555,20 +411,17 @@
 }
 
+/* End a sequence or set */
 static int
 ber_put_seqorset( BerElement *ber )
 {
-	int rc;
-	ber_len_t	len;
-	unsigned char netlen[sizeof(ber_len_t)];
-	int			taglen;
-	ber_len_t	lenlen;
-	unsigned char	ltag = 0x80U + FOUR_BYTE_LEN - 1;
-	Seqorset	*next;
-	Seqorset	**sos = &ber->ber_sos;
+	struct seqorset_header_s header;
+	unsigned char	*lenptr;
+	ber_len_t		len;
+	ptrdiff_t		xlen;		/* length(length octets + contents) */
 
 	assert( ber != NULL );
 	assert( LBER_VALID( ber ) );
 
-	if( *sos == NULL ) return -1;
+	if ( ber->ber_sos_ptr == NULL ) return -1;
 
 	/*
@@ -580,136 +433,40 @@
 	 */
 
-	len = (*sos)->sos_clen;
-
-	if ( sizeof(ber_len_t) > 4 && len > 0xffffffffUL ) {
+	lenptr = (unsigned char *) ber->ber_buf + ber->ber_sos_offset;
+	xlen = ber->ber_sos_ptr - (char *) lenptr;
+	if ( xlen > (ptrdiff_t) (MAXINT_BERSIZE + MAX_LENLEN) ) {
 		return -1;
 	}
 
-	if ( ber->ber_options & LBER_USE_DER ) {
-		lenlen = ber_calc_lenlen( len );
-
-	} else {
-		lenlen = FOUR_BYTE_LEN;
-	}
+	/* Extract sequence/set information from length octets */
+	memcpy( SOS_TAG_END(header), lenptr, MAX_LENLEN );
 
-	if( lenlen > 1 ) {
+	/* Store length, and close gap of leftover reserved length octets */
+	len = xlen - MAX_LENLEN;
+	if ( ber->ber_options & LBER_USE_DER ) {
 		int i;
-		ber_len_t j = len;
-		for( i=lenlen-2; i >= 0; i-- ) {
-			netlen[i] = j & 0xffU;
-			j >>= 8;
+		lenptr[0] = MAX_LENLEN - 1 + 0x80; /* length(length) */
+		for( i = MAX_LENLEN; --i > 0; len >>= 8 ) {
+			lenptr[i] = len & 0xffU;
 		}
 	} else {
-		netlen[0] = (unsigned char)(len & 0x7fU);
-	}
-
-	if ( (next = (*sos)->sos_next) == NULL ) {
-		/* write the tag */
-		if ( (taglen = ber_put_tag( ber, (*sos)->sos_tag, 1 )) == -1 ) {
-			return( -1 );
+		unsigned char *current = ber_prepend_len( lenptr + MAX_LENLEN, len );
+		ptrdiff_t unused = current - lenptr;
+		if ( unused != 0 ) {
+			/* length(length) < the reserved FOUR_BYTE_LEN bytes */
+			xlen -= unused;
+			AC_MEMCPY( lenptr, current, xlen );
+			ber->ber_sos_ptr = (char *) lenptr + xlen;
 		}
+	}
 
-		if ( ber->ber_options & LBER_USE_DER ) {
-			/* Write the length in the minimum # of octets */
-			if ( ber_put_len( ber, len, 1 ) == -1 ) {
-				return -1;
-			}
-
-			if (lenlen != FOUR_BYTE_LEN) {
-				/*
-				 * We set aside FOUR_BYTE_LEN bytes for
-				 * the length field.  Move the data if
-				 * we don't actually need that much
-				 */
-				AC_MEMCPY( (*sos)->sos_first + taglen +
-				    lenlen, (*sos)->sos_first + taglen +
-				    FOUR_BYTE_LEN, len );
-			}
-		} else {
-			/* Fill FOUR_BYTE_LEN bytes for length field */
-			/* one byte of length length */
-			if ( ber_write( ber, (char *)&ltag, 1, 1 ) != 1 ) {
-				return -1;
-			}
-
-			/* the length itself */
-			rc  = ber_write( ber, (char *) netlen, FOUR_BYTE_LEN-1, 1 );
-
-			if( rc != FOUR_BYTE_LEN - 1 ) {
-				return -1;
-			}
-		}
+	ber->ber_sos_offset = header.next_sos.offset;
+	if ( header.next_sos.offset == 0 ) { /* outermost sequence/set? */
 		/* The ber_ptr is at the set/seq start - move it to the end */
-		(*sos)->sos_ber->ber_ptr += len;
-
-	} else {
-		int i;
-		unsigned char nettag[sizeof(ber_tag_t)];
-		ber_tag_t tmptag = (*sos)->sos_tag;
-
-		if( ber->ber_sos->sos_ptr > ber->ber_end ) {
-			/* The sos_ptr exceeds the end of the BerElement
-			 * this can happen, for example, when the sos_ptr
-			 * is near the end and no data was written for the
-			 * 'V'.	 We must realloc the BerElement to ensure
-			 * we don't overwrite the buffer when writing
-			 * the tag and length fields.
-			 */
-			ber_len_t ext = ber->ber_sos->sos_ptr - ber->ber_end;
-
-			if( ber_realloc( ber,  ext ) != 0 ) {
-				return -1;
-			}
-		}
-
-		/* the tag */
-		taglen = ber_calc_taglen( tmptag );
-
-		for( i = taglen-1; i >= 0; i-- ) {
-			nettag[i] = (unsigned char)(tmptag & 0xffU);
-			tmptag >>= 8;
-		}
-
-		AC_FMEMCPY( (*sos)->sos_first, nettag, taglen );
-
-		if ( ber->ber_options & LBER_USE_DER ) {
-			ltag = (lenlen == 1)
-				? (unsigned char) len
-				: (unsigned char) (0x80U + (lenlen - 1));
-		}
-
-		/* one byte of length length */
-		(*sos)->sos_first[1] = ltag;
-
-		if ( ber->ber_options & LBER_USE_DER ) {
-			if (lenlen > 1) {
-				/* Write the length itself */
-				AC_FMEMCPY( (*sos)->sos_first + 2, netlen, lenlen - 1 );
-			}
-			if (lenlen != FOUR_BYTE_LEN) {
-				/*
-				 * We set aside FOUR_BYTE_LEN bytes for
-				 * the length field.  Move the data if
-				 * we don't actually need that much
-				 */
-				AC_FMEMCPY( (*sos)->sos_first + taglen +
-				    lenlen, (*sos)->sos_first + taglen +
-				    FOUR_BYTE_LEN, len );
-			}
-		} else {
-			/* the length itself */
-			AC_FMEMCPY( (*sos)->sos_first + taglen + 1,
-			    netlen, FOUR_BYTE_LEN - 1 );
-		}
-
-		next->sos_clen += (taglen + lenlen + len);
-		next->sos_ptr += (taglen + lenlen + len);
+		ber->ber_ptr = ber->ber_sos_ptr;
+		ber->ber_sos_ptr = NULL;
 	}
 
-	/* we're done with this seqorset, so free it up */
-	ber_memfree_x( (char *) (*sos), ber->ber_memctx );
-	*sos = next;
-
-	return taglen + lenlen + len;
+	return (int) xlen + *SOS_TAG_END(header);
 }
 
@@ -717,7 +474,4 @@
 ber_put_seq( BerElement *ber )
 {
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
-
 	return ber_put_seqorset( ber );
 }
@@ -726,7 +480,4 @@
 ber_put_set( BerElement *ber )
 {
-	assert( ber != NULL );
-	assert( LBER_VALID( ber ) );
-
 	return ber_put_seqorset( ber );
 }
--- openldap-2.4.17/libraries/liblber/io.c	2008-07-10 01:16:48.000000000 +0200
+++ openldap-2.4.17/libraries/liblber/io.c	2009-07-23 23:57:07.000000000 +0200
@@ -97,26 +97,17 @@
 	int nosos )
 {
+	char **p;
+
 	assert( ber != NULL );
 	assert( buf != NULL );
-
 	assert( LBER_VALID( ber ) );
 
-	if ( nosos || ber->ber_sos == NULL ) {
-		if ( ber->ber_ptr + len > ber->ber_end ) {
-			if ( ber_realloc( ber, len ) != 0 ) return( -1 );
-		}
-		AC_MEMCPY( ber->ber_ptr, buf, (size_t)len );
-		ber->ber_ptr += len;
-		return( (ber_slen_t) len );
-
-	} else {
-		if ( ber->ber_sos->sos_ptr + len > ber->ber_end ) {
-			if ( ber_realloc( ber, len ) != 0 ) return( -1 );
-		}
-		AC_MEMCPY( ber->ber_sos->sos_ptr, buf, (size_t)len );
-		ber->ber_sos->sos_ptr += len;
-		ber->ber_sos->sos_clen += len;
-		return( (ber_slen_t) len );
-	}
+	p = nosos || ber->ber_sos_ptr == NULL ? &ber->ber_ptr : &ber->ber_sos_ptr;
+	if ( *p + len > ber->ber_end ) {
+		if ( ber_realloc( ber, len ) != 0 ) return( -1 );
+	}
+	AC_MEMCPY( *p, buf, len );
+	*p += len;
+	return( (ber_slen_t) len );
 }
 
@@ -124,8 +115,8 @@
 ber_realloc( BerElement *ber, ber_len_t len )
 {
-	ber_len_t	total;
+	ber_len_t	total, offset, sos_offset;
 	Seqorset	*s;
 	long		off;
-	char		*oldbuf;
+	char		*buf;
 
 	assert( ber != NULL );
@@ -135,5 +126,5 @@
 	total = ber_pvt_ber_total( ber );
 
-#define LBER_EXBUFSIZ	4060 /* a few words less than 2^N for binary buddy */
+#define LBER_EXBUFSIZ	4059 /* a few words less than 2^N for binary buddy */
 #if defined( LBER_EXBUFSIZ ) && LBER_EXBUFSIZ > 0
 # ifndef notdef
@@ -151,32 +142,19 @@
 #endif
 
-	oldbuf = ber->ber_buf;
-
-	ber->ber_buf = (char *) ber_memrealloc_x( oldbuf, total, ber->ber_memctx );
-	
-	if ( ber->ber_buf == NULL ) {
-		ber->ber_buf = oldbuf;
+	buf = ber->ber_buf;
+	offset = ber->ber_ptr - buf;
+	sos_offset = ber->ber_sos_ptr ? ber->ber_sos_ptr - buf : 0;
+
+	/* the +1 lets ber_flatten() \0-terminate buf */
+	buf = (char *) ber_memrealloc_x( buf, total + 1, ber->ber_memctx );
+	if ( buf == NULL ) {
 		return( -1 );
 	}
 
-	ber->ber_end = ber->ber_buf + total;
-
-	/*
-	 * If the stinking thing was moved, we need to go through and
-	 * reset all the sos and ber pointers.	Offsets would've been
-	 * a better idea... oh well.
-	 */
-
-	if ( ber->ber_buf != oldbuf ) {
-		ber->ber_ptr = ber->ber_buf + (ber->ber_ptr - oldbuf);
-
-		for ( s = ber->ber_sos; s != NULL; s = s->sos_next ) {
-			off = s->sos_first - oldbuf;
-			s->sos_first = ber->ber_buf + off;
-
-			off = s->sos_ptr - oldbuf;
-			s->sos_ptr = ber->ber_buf + off;
-		}
-	}
+	ber->ber_buf = buf;
+	ber->ber_end = buf + total;
+	ber->ber_ptr = buf + offset;
+	if ( sos_offset )
+		ber->ber_sos_ptr = buf + sos_offset;
 
 	return( 0 );
@@ -192,11 +170,7 @@
 	if ( ber->ber_buf) ber_memfree_x( ber->ber_buf, ber->ber_memctx );
 
-	for( s = ber->ber_sos ; s != NULL ; s = next ) {
-		next = s->sos_next;
-		ber_memfree_x( s, ber->ber_memctx );
-	}
-
 	ber->ber_buf = NULL;
-	ber->ber_sos = NULL;
+	ber->ber_sos_ptr = NULL;
+	ber->ber_sos_offset = 0;
 	ber->ber_valid = LBER_UNINITIALIZED;
 }
@@ -416,8 +390,11 @@
 			}
 			AC_MEMCPY( bv->bv_val, ber->ber_buf, len );
+			bv->bv_val[len] = '\0';
+		} else if ( ber->ber_buf == NULL ) {
+			bv->bv_val = "";
 		} else {
 			bv->bv_val = ber->ber_buf;
+			bv->bv_val[len] = '\0';
 		}
-		bv->bv_val[len] = '\0';
 		bv->bv_len = len;
 	}
@@ -726,5 +703,6 @@
 {
 	ber->ber_rwptr = NULL;
-	ber->ber_sos = NULL;
+	ber->ber_sos_ptr = NULL;
+	ber->ber_sos_offset = 0;
 	ber->ber_end = ber->ber_ptr;
 	ber->ber_ptr = ber->ber_buf;
--- openldap-2.4.17/libraries/liblber/lber-int.h	2008-02-12 00:26:41.000000000 +0100
+++ openldap-2.4.17/libraries/liblber/lber-int.h	2009-07-24 07:36:25.000000000 +0200
@@ -88,5 +88,6 @@
 	char		*ber_end;
 
-	struct seqorset	*ber_sos;
+	char		*ber_sos_ptr;
+#	define		ber_sos_offset ber_len /* reuse ber_len for binary compat */
 	char		*ber_rwptr;
 	void		*ber_memctx;
@@ -116,13 +117,4 @@
 #define SOCKBUF_VALID( sb )	( (sb)->sb_valid == LBER_VALID_SOCKBUF )
 
-struct seqorset {
-	BerElement	*sos_ber;
-	ber_len_t	sos_clen;
-	ber_tag_t	sos_tag;
-	char		*sos_first;
-	char		*sos_ptr;
-	struct seqorset	*sos_next;
-};
-
 
 /*
