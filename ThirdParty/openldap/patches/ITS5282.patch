--- openldap-2.3.40/servers/slapd/syncrepl.c.orig	2008-01-16 15:56:25.000000000 -0800
+++ openldap-2.3.40/servers/slapd/syncrepl.c	2008-01-16 17:00:27.000000000 -0800
@@ -634,8 +634,6 @@
 	int	rc, err, i;
 	ber_len_t	len;
 
-	int rc_efree = 1;
-
 	struct berval	*psub;
 	Modifications	*modlist = NULL;
 
@@ -718,19 +716,19 @@
 						slap_parse_sync_cookie( &syncCookie, NULL );
 					}
 				}
+				rc = 0;
 				if ( si->si_syncdata && si->si_logstate == SYNCLOG_LOGGING ) {
-					entry = NULL;
 					modlist = NULL;
-					if ( syncrepl_message_to_op( si, op, msg ) == LDAP_SUCCESS &&
+					if (( rc = syncrepl_message_to_op( si, op, msg )) == LDAP_SUCCESS &&
 						!BER_BVISNULL( &syncCookie.ctxcsn ) ) {
 						syncrepl_updateCookie( si, op, psub, &syncCookie );
 					}
-				} else if ( syncrepl_message_to_entry( si, op, msg,
-					&modlist, &entry, syncstate ) == LDAP_SUCCESS ) {
-					rc_efree = syncrepl_entry( si, op, entry, &modlist,
-						syncstate, &syncUUID, &syncCookie_req, &syncCookie.ctxcsn );
-					if ( !BER_BVISNULL( &syncCookie.ctxcsn ) )
-					{
+				} else if (( rc = syncrepl_message_to_entry( si, op, msg,
+					&modlist, &entry, syncstate )) == LDAP_SUCCESS ) {
+					if (( rc = syncrepl_entry( si, op, entry, &modlist,
+						syncstate, &syncUUID, &syncCookie_req,
+						&syncCookie.ctxcsn )) == LDAP_SUCCESS &&
+						!BER_BVISNULL( &syncCookie.ctxcsn ) ) {
 						syncrepl_updateCookie( si, op, psub, &syncCookie );
 					}
 				}
@@ -738,10 +736,8 @@
 				if ( modlist ) {
 					slap_mods_free( modlist, 1 );
 				}
-				if ( rc_efree && entry ) {
-					entry_free( entry );
-				}
-				entry = NULL;
+				if ( rc )
+					goto done;
 				break;
 
 			case LDAP_RES_SEARCH_REFERENCE:
@@ -1528,7 +1524,6 @@
 	}
 
 	e = entry_alloc();
-	*entry = e;
 	e->e_name = op->o_req_dn;
 	e->e_nname = op->o_req_ndn;
 
@@ -1604,9 +1599,10 @@
 	if ( rc != LDAP_SUCCESS ) {
 		if ( e ) {
 			entry_free( e );
-			*entry = e = NULL;
+			e = NULL;
 		}
 	}
+	*entry = e;
 
 	return rc;
 }
@@ -1669,7 +1665,6 @@
 	AttributeAssertion ava = { NULL, BER_BVNULL };
 #endif
 	int rc = LDAP_SUCCESS;
-	int ret = LDAP_SUCCESS;
 
 	struct berval pdn = BER_BVNULL;
 	dninfo dni = {0};
@@ -1838,15 +1833,15 @@
 			switch ( rs_add.sr_err ) {
 			case LDAP_SUCCESS:
 				be_entry_release_w( op, entry );
-				ret = 0;
+				entry = NULL;
 				break;
 
 			case LDAP_REFERRAL:
 			/* we assume that LDAP_NO_SUCH_OBJECT is returned 
 			 * only if the suffix entry is not present */
 			case LDAP_NO_SUCH_OBJECT:
-				syncrepl_add_glue( op, entry );
-				ret = 0;
+				rc = syncrepl_add_glue( op, entry );
+				entry = NULL;
 				break;
 
 			/* if an entry was added via syncrepl_add_glue(),
@@ -1882,7 +1877,8 @@
 					cb2.sc_response = dn_callback;
 					cb2.sc_private = &dni;
 
-					be->be_search( &op2, &rs2 );
+					rc = be->be_search( &op2, &rs2 );
+					if ( rc ) goto done;
 
 					retry = 0;
 					slap_op_time( &op->o_time, &op->o_tincr );
@@ -1894,7 +1890,6 @@
 				Debug( LDAP_DEBUG_ANY,
 					"syncrepl_entry: rid %03d be_add failed (%d)\n",
 					si->si_rid, rs_add.sr_err, 0 );
-				ret = 1;
 				break;
 			}
 			goto done;
@@ -1920,6 +1915,10 @@
 				op->orr_nnewSup = NULL;
 			}
 			op->orr_deleteoldrdn = 0;
+			op->orr_modlist = NULL;
+			if (( rc = slap_modrdn2mods( op, &rs_modify ))) {
+				goto done;
+			}
 			rc = be->be_modrdn( op, &rs_modify );
 			Debug( LDAP_DEBUG_SYNC,
 					"syncrepl_entry: rid %03d be_modrdn (%d)\n", 
@@ -1928,7 +1927,6 @@
 				op->o_req_dn = entry->e_name;
 				op->o_req_ndn = entry->e_nname;
 			} else {
-				ret = 1;
 				goto done;
 			}
 			if ( dni.wasChanged )
@@ -1996,7 +1994,6 @@
 					si->si_rid, rs_modify.sr_err, 0 );
 			}
 		}
-		ret = 1;
 		goto done;
 	case LDAP_SYNC_DELETE :
 		if ( !BER_BVISNULL( &dni.dn )) {
@@ -2024,13 +2021,11 @@
 				}
 			}
 		}
-		ret = 0;
 		goto done;
 
 	default :
 		Debug( LDAP_DEBUG_ANY,
 			"syncrepl_entry: rid %03d unknown syncstate\n", si->si_rid, 0, 0 );
-		ret = 1;
 		goto done;
 	}
 
@@ -2048,8 +2043,10 @@
 	if ( !BER_BVISNULL( &dni.dn ) ) {
 		op->o_tmpfree( dni.dn.bv_val, op->o_tmpmemctx );
 	}
+	if ( entry )
+		entry_free( entry );
 	BER_BVZERO( &op->o_csn );
-	return ret;
+	return rc;
 }
 
 static struct berval gcbva[] = {
@@ -2222,7 +2219,7 @@
 	return;
 }
 
-void
+int
 syncrepl_add_glue(
 	Operation* op,
 	Entry *e )
@@ -2330,6 +2327,10 @@
 		} else {
 		/* incl. ALREADY EXIST */
 			entry_free( glue );
+			if ( rs_add.sr_err != LDAP_ALREADY_EXISTS ) {
+				entry_free( e );
+				return rc;
+			}
 		}
 
 		/* Move to next child */
@@ -2360,7 +2361,7 @@
 		entry_free( e );
 	}
 
-	return;
+	return rc;
 }
 
 static void
