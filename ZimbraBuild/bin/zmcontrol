#!/usr/bin/perl
# 
# ***** BEGIN LICENSE BLOCK *****
# Version: ZPL 1.1
# 
# The contents of this file are subject to the Zimbra Public License
# Version 1.1 ("License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.zimbra.com/license
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
# the License for the specific language governing rights and limitations
# under the License.
# 
# The Original Code is: Zimbra Collaboration Suite.
# 
# The Initial Developer of the Original Code is Zimbra, Inc.
# Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
# All Rights Reserved.
# 
# Contributor(s):
# 
# ***** END LICENSE BLOCK *****
# 

#use strict;

use strict;

BEGIN {
	our $Basedir = "/opt/zimbra/zimbramon";
};
our $Basedir = "/opt/zimbra/zimbramon";

my $configfile = "$Basedir/zimbra.cf";

use lib "/opt/zimbra/zimbramon/lib/Zimbra/Mon";
use lib "/opt/zimbra/zimbramon/lib";

use Zimbra::Mon::Logger;
use Zimbra::Mon::Control;

use Getopt::Std;

use POSIX ":sys_wait_h";
use SOAP::Lite;

#use SOAP::Lite +trace;
use SOAP::Transport::HTTP;
use HTTP::Request;
use LWP::UserAgent;

our $StatusRunning  = 0;
our $StatusStarting = 1;
our $StatusStopped  = 2;
our $StatusStopping = 3;

our @applications;
our @services;
our @localservices;
our %syntaxes;

my $controlport = 0;

our $Cluster;

our %GlobalOpts;

our $Command;
our @Args;

my %FUNCTIONS = (
	'reload'		=>	'ReloadRequest',
	'status'        =>	'GetServiceInfoRequest',
	'start'         =>	'start',
	'stop'          =>	'stop',
	'shutdown'		=>	'ShutDownRequest',
	'startup'		=>	'startup',
	'maintenance'	=>	'maintenance',
);

my %HELP = (
	'GetHostListRequest'		=> 'Returns a list of configured hosts',
	'GetShortInfoRequest'		=> 'Returns info for named host',
	'GetServiceInfoRequest'		=> 'Returns services info for named host',
	'ServiceControlRequest'		=> 'start/stop services for named host',
	'ShutDownRequest'			=> 'Shut down all services and manager on THIS host',
	'startup'					=> 'Startup manager and all services on THIS host',
	'start'					=> 'Startup manager and all services on THIS host',
	'maintenance'				=> 'Set maintenance mode for this server',
	'reload'					=> 'Restart manager server, no effect on services',
	'stop'						=> 'Stop services on this host',
);

my @STATUS = ("Running", "Starting", "Stopped", "Stopping");

$SIG{INT}=\&handleSig;

#
# May not need to surface these at the command line (maybe for testing?)
#
#	GetLocalEventsRequest
#	updateClusterInfoRequest

sub handleSig {
	exit 1;
}

sub displayResult {
	my $pref = shift;
	my $res  = shift;
	my $ret = 0;
	if ( ref $res ) {

		#				print "$pref".sprintf("%-20s", $_)." (".ref ($res).")\n";
		if ( ref $res eq "ARRAY" ) {
			my $q;
			foreach $q ( @{$res} ) {
				$ret += displayResult( $pref, $q );
			}
		}
		else {    # HASH or object
			if (ref($res) eq "HASH") {
			} else {
				print "$pref".ref($res)."\n";
			}
			my $q;
			foreach $q ( sort keys %{$res} ) {
				if ( ref($$res{$q}) ) { 
					print "$pref".$q."\n";
					$ret += displayResult( $pref, $$res{$q} ); 
				}
				else {
					if ($q eq "status") {
						print "\t$pref" . sprintf( "%-20s", $q ) . $STATUS[$$res{$q}]."\n";
						if ($$res{$q}) {$ret = 1;}

					} elsif (
						$q eq "info"
						) {
						# Skip this.
					} else {
						print "\t$pref" . sprintf( "%-20s", $q ) . "$$res{$q}\n";
					}
				}

				#$ret += displayResult("\t".$pref, $q);
			}
		}
	}
	else {
		if (
			$_ eq "cts"  || 
			$_ eq "uts"  || 
			$_ eq "ts" 	 || 
			$_ =~ /File/ || 
			$_ =~ /Dir/
			) {
			# Skip these
		} else {
			print "$pref" . sprintf( "%-20s", $_ ) . "$res\n";
		}
	}
	return $ret;
}

sub doStartup {
	Zimbra::Mon::Logger::Log ("info", "Doing startup");
	
	my ($dir) = ($0 =~ m/^(.*\/)/);
	
	my $cmd = "perl $dir"."zmmon &";
	print $cmd."\n\n";
	system ("$cmd");
}

sub doStart {
	Zimbra::Mon::Logger::Log ("info", "Starting services");
	Zimbra::Mon::Control::startServices();
}

sub doStop {
	Zimbra::Mon::Control::stopServices();
}

sub setMaintenanceMode {
	my $mode = shift;
	return Zimbra::Mon::Control::setMaintenance($mode);
}

sub clientCall {
	print "Calling $Command (@Args)\n\n";
	
	my $ret = 0;

	if ($Command eq "maintenance" ) {
		shift @Args;
		if ($#Args >= 0 && $Args[0] ne "status") {
			return setMaintenanceMode(@Args);
		}
		if (Zimbra::Mon::Control::isMaintenanceMode()) {
			print "Maintenance mode is ON\n";
			return 1;
		}else{
			print "Maintenance mode is OFF\n";
			return 0;
		}
	}

	if ($Command eq "startup" || $Command eq "start" ) {
		doStart();
		doStartup();
		sleep 5;
		getCommand("status");
		# getCommand("start");
	}

	if ($Command eq "ShutDownRequest" || $Command eq "stop" ) {
		doStop();
	}

	if ($Command eq "stop") {
		getCommand("status");
		return (clientCall());
	}
	
	my $resp;
	eval {
		$resp =
		  SOAP::Lite->proxy('http://localhost:7777/')
		  ->uri('http://localhost:7777/Zimbra::Mon::Admin')->call( $Command => @Args );

	};

	if ($@ && $Command ne "ShutDownRequest") {
		if (Zimbra::Mon::Control::isMaintenanceMode()) {
			print "NOTE: This server is in maintenance mode\n\n";
			exit (0);
		}
		print STDERR "Soap call failed: $@\n";
		exit (1);
	}

	if ($Command eq "ShutDownRequest") {
		# Special case for pkg removal
		exit(0);
	}

	#           print "r: ".$resp->result->{name}."\n";
	my $p;
	my @p = $resp->paramsall();
	if (Zimbra::Mon::Control::isMaintenanceMode()) {
		print "NOTE: This server is in maintenance mode\n\n";
	}
	foreach $p (@p) {
		print "RESPONSE: (".ref($p).")\n";
		if (ref($p)) {
			if (ref($p) eq "ARRAY") {
				foreach ( @{$p} ) {
					$ret += displayResult( "\t", $_ );
				}
			} else {
				foreach ( sort keys %{$p} ) {
					$ret += displayResult( "\t", $$p{$_} );
				}
			}
		} else {
			$ret += displayResult( "\t", $p );
		}
	}
	if ($Command eq "ServiceControlRequest") {
		# sleep 20;
		getCommand("status");
		return (clientCall());
	}
	if (Zimbra::Mon::Control::isMaintenanceMode()) {
		print "\nNOTE: This server is in maintenance mode\n\n";
		$ret = 0;
	}
	return $ret;
}

sub getCommand {
	my $c = shift;

	$c = lc ($c);

	unless ( defined $FUNCTIONS{$c} ) { return 0; }

	my $cmd = $FUNCTIONS{$c};

	@Args    = @_;
	if ($cmd eq "ServiceControlRequest") {
		unshift @Args, $c;
	}
	unshift @Args, $GlobalOpts{H};
	$Command = $cmd;
	# print "COMMAND: $Command\n";

	return 1;
}

sub getHostName {
	my $h = `zmlocalconfig -m nokey zimbra_server_hostname`;
	chomp $h;
	return $h;
}

sub getCommandLine {
	unless ( getopts( 'vhdH:', \%GlobalOpts ) ) { usage(); }

	if ( ! $GlobalOpts{H} ) { $GlobalOpts{H} = getHostName(); chomp $GlobalOpts{H}; }

	if ( $GlobalOpts{h} ) { usage(); }
	if ( $GlobalOpts{v} ) { displayVersion(); exit 1;}

	unless ( getCommand(@ARGV) ) { print STDERR "Unknown command\n"; usage(); }

}

sub displayVersion {
	my $release = `rpm -q --queryformat "%{version}_%{release}" zimbra-core`;
	my $inst = localtime (`rpm -q --queryformat "%{installtime}" zimbra-core`);
	print "\nRelease $release installed $inst\n\n";
}

sub usage {
	displayVersion();
	print "$0 [-v -h -d -H <host>] command [args]\n";
	print "\n";
	print "\t-v:	display version\n";
	print "\t-h:	print usage statement\n";
	print "\t-d:	debug\n";
	print "\t-H:	Host name (localhost)\n";
	print "\n";
	print "\tCommand in:\n";
	foreach ( sort keys %FUNCTIONS ) {
		print "\t\t" . sprintf( "%-20s", $_ ) . "$HELP{$FUNCTIONS{$_}}\n";
	}

	print "\n";
	exit 1;
}

Zimbra::Mon::Control::loadConfig($configfile);
getCommandLine();
exit (clientCall());

