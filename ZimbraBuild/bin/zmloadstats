#!/usr/bin/perl
# 
# ***** BEGIN LICENSE BLOCK *****
# Version: ZPL 1.1
# 
# The contents of this file are subject to the Zimbra Public License
# Version 1.1 ("License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.zimbra.com/license
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
# the License for the specific language governing rights and limitations
# under the License.
# 
# The Original Code is: Zimbra Collaboration Suite.
# 
# The Initial Developer of the Original Code is Zimbra, Inc.
# Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
# All Rights Reserved.
# 
# Contributor(s):
# 
# ***** END LICENSE BLOCK *****
# 

use strict;
use lib '/opt/zimbra/zimbramon/lib';

my $DEBUG=0;

use DBI;
use Time::Local;

my $baseDir = "/opt/zimbra";
my $logDir = "$baseDir/log";

my $data_source="dbi:mysql:database=zimbra;mysql_read_default_file=/opt/zimbra/conf/my.cnf;mysql_socket=/opt/zimbra/db/mysql.sock";
my $username="zimbra";
my $password = `/opt/zimbra/bin/zmlocalconfig -s zimbra_mysql_password`;
chomp $password;
$password = (split(' ',$password))[2];

my $dbh = DBI->connect($data_source, $username, $password);

if (!$dbh) { 
	print STDERR "DB: Can't connect to $data_source: $DBI::errstr\n";
	exit 1;
#	Zimbra::Logger::Log ("err", "DB: Can't connect to $data_source: $DBI::errstr");
#	return undef;
}

sub datetime_to_timestamp {
	my $dt = shift;
	if ($dt eq "" || !defined ($dt)) {
		return "0000000000";
	}
	my ($year,$mon,$mday,$hour,$min,$sec) = 
		($dt =~ m/(\d+)-(\d+)-(\d+) (\d+):(\d+):(\d+)/);
	my $ts = timelocal($sec,$min,$hour,$mday,$mon-1,$year);
	return $ts;
}

sub timestamp_to_datetime {
	my $ts = shift;
	if ($ts eq "" || !defined($ts)) {
		return '1000-01-01 00:00:00';
	}
	my @s= localtime($ts);

 	#'YYYY-MM-DD HH:MM:SS'
	my $dt = sprintf ("%4d-%02d-%02d %02d:%02d:%02d",$s[5]+1900,$s[4]+1,$s[3],$s[2],$s[1],$s[0]);
	return $dt;
}


sub get_last_timestamp {
	my $ts;

	my $statement = "select max(time) from server_stat";

	my $sth = $dbh->prepare($statement);

	if (!$sth->execute) {
		Zimbra::Logger::Log ("err", "DB: $sth->errstr");
		return undef;
	}

	my @ary = $sth->fetchrow_array;

	return (datetime_to_timestamp($ary[0]));
	
}

sub get_file_list {
	my $ts = shift;

	opendir (DIR, $logDir);
	my @files = grep /^zimbrastats-\d+\.log/, readdir DIR;
	closedir DIR;

	# logfiles are zimbrastats.<create_time_stamp>.log 
	# so we want all where create_time_stamp > ts, plus
	# the first one previous.
	@files = reverse sort @files;
	my @list;
	foreach (@files)
	{
		my ($ft) = ($_ =~ m/zimbrastats-(\d+)\.log/);

		push @list, $_;

		if ($ft <= $ts) {last;}
	}

	return \@list;

}

sub read_files {
	my $ts = shift;
	my $list = shift;

	foreach my $file (@$list) {
		($DEBUG) && print STDERR ("Reading: $logDir/$file\n");

		open (FILE, "$logDir/$file");
		my @lines = <FILE>;
		close FILE;

		my @headers = ();

		# Header lines are timestamp plus text.
		foreach (@lines) {
			chomp;
			my @fields = split /,/;
			if ($fields[1] =~ m/^[a-zA-Z]/) {
				shift (@fields);
				@headers = @fields;
				($DEBUG) && print STDERR "NEW HEADERS ($#headers): @headers\n\n";
				next;
			}
			my $ct = shift (@fields);
			if ($ct <= $ts) {next;}

			my $statement = 
				"insert into server_stat(time, name, value) values (?,?,?)";

			my $sth = $dbh->prepare($statement);

			my $dt = timestamp_to_datetime($ct);

			($DEBUG) && print STDERR "TIME: $dt\n";

			for (my $i = 0; $i <= $#fields; $i++) {
				
				($DEBUG) && print STDERR "$dt, $headers[$i], $fields[$i]\n";
				if (!$sth->execute($dt, $headers[$i], $fields[$i]) ) {
					Zimbra::Logger::Log ("err", "DB: $sth->errstr");
					return undef;
				}

			}

		}
	}

}

my $ts = get_last_timestamp();
($DEBUG) && print STDERR "Timestamp: $ts\n";
my $list = get_file_list($ts);
read_files($ts,$list);
