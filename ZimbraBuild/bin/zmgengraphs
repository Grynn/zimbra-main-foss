#!/usr/bin/perl
# 
# ***** BEGIN LICENSE BLOCK *****
# Version: ZPL 1.1
# 
# The contents of this file are subject to the Zimbra Public License
# Version 1.1 ("License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.zimbra.com/license
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
# the License for the specific language governing rights and limitations
# under the License.
# 
# The Original Code is: Zimbra Collaboration Suite.
# 
# The Initial Developer of the Original Code is Zimbra, Inc.
# Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
# All Rights Reserved.
# 
# Contributor(s):
# 
# ***** END LICENSE BLOCK *****
# 

use strict;
use lib '/opt/zimbra/zimbramon/lib';
use lib '/opt/zimbra/zimbramon/lib/Zimbra/Mon';

my $DEBUG=0;

use DBI;
use Time::Local;
use Zimbra::Logger;

my @DATANAMES=(
	"LmtpRcvdData:total:bytes",
	"LmtpRcvdMsgs:total:count",
	"Slice:/opt/zimbra",
	"Slice:/opt/zimbra/db",
	"Slice:/opt/zimbra/index",
	"Slice:/opt/zimbra/log",
	"Slice:/opt/zimbra/redolog",
	"Slice:/opt/zimbra/store"
	);

my $baseDir = "/opt/zimbra";
my $logDir = "$baseDir/log";

my $data_source="dbi:mysql:database=zimbra;mysql_read_default_file=/opt/zimbra/conf/my.cnf;mysql_socket=/opt/zimbra/db/mysql.sock";
my $username="zimbra";
my $password = `/opt/zimbra/bin/zmlocalconfig -s -m nokey zimbra_mysql_password`;
chomp $password;

my $pstring;
my $beg;
my $step;
my $count;

my $dbh = DBI->connect($data_source, $username, $password);

if (!$dbh) { 
	print STDERR "DB: Can't connect to $data_source: $DBI::errstr\n";
	exit 1;
#	Zimbra::Logger::Log ("err", "DB: Can't connect to $data_source: $DBI::errstr");
#	return undef;
}

sub datetime_to_timestamp {
	my $dt = shift;
	if ($dt eq "" || !defined ($dt)) {
		return "0000000000";
	}
	if ($dt =~ m/^\d\d\d\d-\d\d-\d\d$/) {
		$dt .= " 00:00:00";
	}

	my ($year,$mon,$mday,$hour,$min,$sec) = 
		($dt =~ m/(\d+)-(\d+)-(\d+) (\d+):(\d+):(\d+)/);
	my $ts = timelocal($sec,$min,$hour,$mday,$mon-1,$year);
	return $ts;
}

sub timestamp_to_datetime {
	my $ts = shift;
	if ($ts eq "" || !defined($ts)) {
		return '1000-01-01 00:00:00';
	}
	my @s= localtime($ts);

 	#'YYYY-MM-DD HH:MM:SS'
	my $dt = sprintf ("%4d-%02d-%02d %02d:%02d:%02d",$s[5]+1900,$s[4]+1,$s[3],$s[2],$s[1],$s[0]);
	return $dt;
}

sub fetch_timed_values {
    my $sn = shift;
    my $table = shift;
    my $startdate = shift;
    my $date = shift;
	my $period = shift;

    my $statement = "select time, value from $table where name = '$sn' and time > '$startdate' and time <= '$date' and period = '$pstring' order by time asc";

    ($DEBUG) && print STDERR "$statement\n";

    my $sth = $dbh->prepare($statement);

    if (!$sth->execute) {
        Zimbra::Logger::Log ("err", "DB: $sth->errstr");
        return undef;
    }

    my $ary = $sth->fetchall_arrayref;
    return ($ary);
}

# Grab 24 hourly values, convert timestamps, feed to rrd and gen. picture.

# Arguments are period(s)
my $period = $ARGV[1];

my $date = timestamp_to_datetime(time());

foreach my $sn (@DATANAMES) {
	foreach my $period (@ARGV) {

		if ($period eq "d") {
			$pstring = 1;
			$step = 3600;
			$count = 24;
		} elsif ($period eq "3m") {
			$pstring = 24;
			$step = 86400;
			$count = 90;
		} elsif ($period eq "12m") {
			$pstring = 24;
			$step = 86400;
			$count = 365;
		} else {
			print STDERR "Invalid period\n\n";
			next;
		}

		my $startdate = datetime_to_timestamp($date);

		my $xlabel;

		if ($period eq "d") {
			$startdate -= (60*60*24);
			$xlabel = '-x MINUTE:30:HOUR:1:HOUR:4:0:%H --no-minor';
		} elsif ($period eq "3m") {
			$startdate -= (60*60*24*30*3);
			$xlabel = '-x WEEK:1:WEEK:2:WEEK:2:604800:%d/%b';
		} elsif ($period eq "12m") {
			$startdate -= (60*60*24*365);
			$xlabel = '-x DAY:15:MONTH:1:MONTH:2:2592000:%b --no-minor';
		}
		$startdate = timestamp_to_datetime($startdate);

		$beg = '-5y';

		($DEBUG) && print STDERR "SN: $sn\nP: $startdate\nE: $date\n";
		print STDERR "Generate graphs for $sn from $startdate to $date ($period)\n";

		my $name = $sn;
		my $keyname;
		my $massage_disk_slice_data = 0;
		my $unit = "";
		my $upper = "";
		my $lower = "";
		my $max = 0;

		if ($name =~ m/^Slice/) {
			$massage_disk_slice_data = 1;
			$unit = "--unit MB -v MB";
			$lower = "-l 0";
			$name =~ s|.*/||g;
			$keyname = "/opt/zimbra/$name";
			if ($keyname eq "/opt/zimbra/zimbra") {
				$keyname = "/opt/zimbra";
			}
		} else {
			$name =~ s/:.*//g;
			$keyname = $name;
		}

		my $vals = fetch_timed_values ($sn, "aggregate_stat", $startdate, $date, $period);

		my $base = "/opt/zimbra/zimbramon/rrdtool";
		my $work = "${base}/work";
		my $rrd = "${base}/bin/rrdtool";
		my $db = "${work}/${name}.${period}.rrd";
		my $graph = "${work}/${name}.${period}.gif";

		if (! -d $work) {mkdir ($work, 0777);}

		unlink -f $db;

		($DEBUG) && print STDERR 
		"$rrd create $db -b $beg -s $step DS:$name:GAUGE:86400:U:U RRA:AVERAGE:0.2:1:$count\n";
		`$rrd create $db -b $beg -s $step DS:$name:GAUGE:86400:U:U RRA:AVERAGE:0.2:1:$count`;

		my $sts = -1;
		my $ets = -1;

		foreach my $row (@$vals) {
			# print STDERR "Found $$row[0] $$row[1]\n";
			my $val = $$row[1];

			if ($massage_disk_slice_data) {
				# val:used:avail:dev:blk
				my @fields = split ':', $val;
				$val = $fields[1];
				if ( $fields[4] > $max ) {
					$max = $fields[4];
					$upper = "-u $max";
				}
				if ($sts == -1) {
					$keyname = "\'$keyname ($fields[3]) (MB)\'";
				}
			}
			my $tm = datetime_to_timestamp($$row[0]);

			if ($sts == -1) {$sts = $tm; $ets = $tm;}
			else {$ets = $tm;}

			($DEBUG) && print STDERR "$rrd update $db $tm:$val\n";
			`$rrd update $db $tm:$val`;
		}

		if ($sts eq "-1" || $ets eq "-1") {
			print STDERR "No values returned\n";
			next;
		}

		($DEBUG) && print STDERR "$rrd graph $graph --start $sts --end $ets $upper $lower $unit $xlabel DEF:count=${db}:${name}:AVERAGE LINE2:count#ff0000:$keyname\n";
		`$rrd graph $graph --start $sts --end $ets $upper $lower $unit $xlabel DEF:count=${db}:${name}:AVERAGE LINE2:count#ff0000:$keyname`;
	}
}
