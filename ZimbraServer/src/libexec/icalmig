#!/usr/bin/perl
#
# ***** BEGIN LICENSE BLOCK *****
#
# Zimbra Collaboration Suite Server
# Copyright (C) 2007-2008 Zimbra, Inc.
#
# The contents of this file are subject to the Yahoo! Public License
# Version 1.0 ("License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://www.zimbra.com/license.
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
#
# ***** END LICENSE BLOCK *****
#
#Convert Oracle Corporate Time iCal file to Zimbra adoptable format
#
use Cwd;
use Date::Calc qw(:all);
use strict;
my $DEBUG = 0;
#global constants
my $version = "1.17";
my $newfileext=".zimbra";
my $bakfileext=".bak";
my $invalidfileext=".invalid";
my @TZHeader;
my $TZTag="";

#get script directory
my $progdir = cwd;
#keep log file in script directory
my $logfilepath;
if ($DEBUG)
{
  $logfilepath="c:\\opt\\zimbra\\log";
}
else
{
  $logfilepath="/opt/zimbra/log";
}
my $logfilename = "icalmig.log";
my $logfile;
my $icalfile;
my $invalidfile;
#used for debug purpose
$icalfile="" if ($DEBUG);

my $outfile;

#used as const values for pattern calcualtions.
my $DAILY = 1,
my $WEEKLY = 7,
my $BIWEEKLY=14,
my $MONTHLY=28,
my $MATCHPC=90,

#default values
#set 1 to delete RDATEs else 0 for no delete
my $deleteRDATE=1;
#set 1 to create exceptions else 0
my $createEXCEPTIONS=1;
#set 1 to create pattern rule else 0
my $createPatternRRULE =1;
#set 1 to use TZ companent and TZ tag else 0
my $useTZcomponent =0;
#over write original file
my $oworginalfile=0;
#for non standard DTSTART (29805)
my $nonStandardDTSTART=0;
# for standard DTSTART(29743)
my $StandardDTSTART=1;

if ($#ARGV<0)
{
  help() if (!$DEBUG);
  exit if (!$DEBUG);
}

#look for command line switches
while ($ARGV[0] =~ /^-(.+)/)
{
  my $switch = $1;
  #pull this switch off of the front of the list
  shift;

  #if they ask for help, do it and exit
  if (($switch eq "h")||($switch eq "help"))
  {
    help();
    exit;
  }
  elsif ($switch eq "v")
  {
    print "VERSION: $version\n";
    exit;
  }
  elsif ($switch eq "f")
  {
    $icalfile = shift;
  }
  elsif ($switch eq "delrdate")
  {
    $deleteRDATE = shift;
  }
  elsif ($switch eq "exceptions")
  {
    $createEXCEPTIONS = shift;
  }
  elsif ($switch eq "patternrule")
  {
    $createPatternRRULE = shift;
  }
  elsif ($switch eq "tz")
  {
    $useTZcomponent = shift;
  }
  elsif ($switch eq "logpath")
  {
    $logfilepath= shift;
  }
  elsif (lc($switch) eq lc("nonStandardDTSTART"))
  {
    $nonStandardDTSTART=1;
  }
  elsif (lc($switch) eq lc("StandardDTSTART"))
  {
    $StandardDTSTART=1;
  }
  else
  {
    print "\nNo such option '$switch'.\n\n";
    help();
    exit;
  }
}
#call functions
&Initialize (@ARGV);
my %rhlist= &processfile;
#&print_hlist(%rhlist);
&UnInitialize;

#help menu
sub help
{
  print "Usage: icalmig -f <ics file> [options]\n";
  print "[options]\n";
  print "-h           (Shows help)  \n";
  print "-v           (Shows Version)\n";
  print "-delrdate    (0-OFF 1-ON ) (DEFAULT: 1)\n";
  print "-exceptions  (0-OFF 1-ON ) (DEFAULT: 1)\n";
  print "-patternrule (0-OFF 1-ON ) (DEFAULT: 1)\n";
  print "-tz          (0-OFF 1-ON ) (DEFAULT: 0)\n";
  print "-nonStandardDTSTART        (Default: 0)\n";
  print "-logpath <path>            (Default /opt/zimbra/log)\n";
  print "\n";
  
}
#Initialize: open logfile and iCal file for parsing
sub Initialize
{
  $logfile= $logfilepath."\/".$logfilename;
  $invalidfile= "$icalfile"."$invalidfileext";
  if (!$icalfile)
  {
    &log_message("No file to process, use -f option.\n");
    exit;
  }
  &log_message("Opening $icalfile...");
  open CFHANDLE, "<$icalfile" or die "Cannot open $icalfile for read :$!";
  &log_message("$icalfile opened successfully.");
  
  #check for log file path (specially for Windows OS)
  my $createdir="mkdir -p $logfilepath";
  if (-d $logfilepath)
  {
    &log_message("$logfilepath exists\n");
  }
  else
  {
    &log_message("mkdir failed\n") unless system($createdir);
  }
  
  #open logfile
  open LFHANDLE, ">$logfile" or die "Cannot open logfile $logfile";
  #open Output file
  $outfile="$icalfile"."$newfileext";
  open OTHANDLE, ">$outfile" or die "can not open output file.";
  #init TZHeader
  &init_TZHeader if $useTZcomponent;
  &log_message("icalmig verison: $version");
}

#unInitialize: close logfile and ical file
sub UnInitialize
{
  #close file handles
  close CFHANDLE;
  close OTHANDLE;
  #close IVHANDLE;
  &log_message("$icalfile and $logfile closed.");
  close LFHANDLE;
  #save original file as bakupfile
  if ($oworginalfile)
  {
    rename($icalfile, $icalfile.$bakfileext);
    rename($outfile, $icalfile);
  }
  &log_message("\n");
  &log_message("*************************************************************");
  &log_message("NOTE:Output file path:$outfile.");
  &log_message("NOTE:Log file path:$logfile.");
  &log_message("*************************************************************");
}

#log_message: log message to file and print to console
sub log_message
{
  my $msg = @_[0];
  chomp($msg);
  print "$msg\n";
  print LFHANDLE "$msg\n";
}

#processfile: do Ical file processing
sub processfile
{
  my $fdelete=0;
  my %hlist=();
  my $rec={};
  my $write_pos = 0;
  my $IsFirstRecId=0;
  my $begreceventpos=0;
  my $prvrecevpos=0;
  my $Iscreaterrule=0;
  my @recdata=();
  my $IsTZHeaderPrinted=0;
  my %hrdate=();
  my $prvuid="";
  my $uidtosrch;
  my $enveventpos=0;
  my $g_isdelrdate=0;
  my $g_isrdate=0;
  my $del_pos=0;
  my $gen_evenstpos=0;
  my $gen_CFsteventpos=0;
  my $wasrulecreated=0;
  my @attendeearr=();
  &log_message("processing file...");
  while (<CFHANDLE>)
  {
    push (@recdata,$_);
    if ($_=~/^BEGIN:VEVENT/)          #start of VEVENT
    {
      #print TZHeader before first VEVENT
      if (($useTZcomponent)&&(!$IsTZHeaderPrinted))
      {
        &log_message("Add TimeZoneHeader.");
        &Add_TZHeader;
        $write_pos = tell OTHANDLE;
        $IsTZHeaderPrinted=1;
      }
      &log_message("Start VEVENT component.");
      $rec={};

      @recdata=();#initialize array
      @attendeearr=();
      push (@recdata,$_);
      
      #set to default value
      $rec->{'MASTER_VEVENT'}=1;
      $rec->{'ISRRULE'}=0;
      $rec->{'ISRDATE'}=0;

      if (!$IsFirstRecId)
      {
        $prvrecevpos =$begreceventpos;
        $begreceventpos= tell OTHANDLE;#remember first rec-id vevent begin pos
        $IsFirstRecId=1;
      }
      $gen_evenstpos= tell OTHANDLE;#generic event start pos
      $gen_CFsteventpos = tell CFHANDLE;#CFHANDLEs generic event start pos
    }
    #RRULE etc will be created on the base of UID change as in some cases, RDATEs
    #are not part of last VEVENT. RDATEs may appear in any VEVENT also. So UID
    #will be used as criteria to check to process group VEVENTS e.g. VEVENTS with
    #same UID.
    elsif ($_=~/^UID:/)               #store UID
    {
      &log_message("$_");
      $rec->{'UID'} = $_;

      #set VEVENT begining point to truncate correclty,
      #even if VEVENTS are not in correct sequence.
      if($prvuid eq "")
      {
        $prvrecevpos=$begreceventpos;
      }
      if (($prvuid ne "")&&($prvuid ne $_))
      {
        $IsFirstRecId=0;#reset
        #shift back to previous VEVENT start point as current one is with next UID
        $del_pos=$prvrecevpos;
        if((!$g_isdelrdate)&&($g_isrdate))
        {
          $Iscreaterrule=1;
          #UID for which processing should be done.
          $uidtosrch=$prvuid;
          $g_isrdate=0;
          $IsFirstRecId=0;#reset
        }
        #if RDATEs should be deleted and current VEVENT has RDATEs
        elsif (($g_isdelrdate)&&($g_isrdate))
        {
          #delete previously added lines due to RRULE+RDATE events.
          #Delete position changes due to no RRULE creation.
          my $dpos= $gen_evenstpos;
          seek OTHANDLE, $dpos, 0;
          truncate OTHANDLE, $dpos or print "UID section:Couldn't truncate: $!\n";
          $begreceventpos= tell OTHANDLE;
        }
      }
      $g_isdelrdate=0;
      $prvuid=$_;
      #if rule was created at previous roll, reset IsFirstRecId
      #else a single event between 2 recurring events gets wiped out.
      if ($wasrulecreated)
      {
        $IsFirstRecId=0;#reset
        $wasrulecreated=0;
      }
    }
    elsif ($_=~/^DTSTART[:;]/)           #store DTSTART
    {
      $rec->{'DTSTART'} = $_;
    }
    elsif ($_=~/^DTEND[:;]/)             #store DTEND
    {
      $rec->{'DTEND'} = $_;
    }
    elsif ($_=~/^LOCATION:/)              #store LOCATION
    {
      my $loc=$_;
      $loc =~ s/^LOCATION://;
      $rec->{'LOCATION'} =$loc;
    }
    elsif ($_=~/^SUMMARY:/)              #store LOCATION
    {
      my $summary=$_;
      $summary =~ s/^SUMMARY://;
      $rec->{'SUMMARY'} =$summary;
    }
    elsif ($_=~/^DESCRIPTION:/)          #store DESCRIPTION
    {
      my $desc=$_;
      $desc =~ s/^DESCRIPTION://;
      $rec->{'DESCRIPTION'} =$desc;
    }
    elsif ($_=~/^RECURRENCE-ID[:;]/)  #store RECURRENCE-ID
    {
      $rec->{'RECURRENCE-ID'}=$_;
      $rec->{'MASTER_VEVENT'}=0;
    }
    elsif ($_=~/^RRULE/)              #check if RRULE is present
    {
      $rec->{'ISRRULE'}=1;
    }
    elsif ($_=~/^RDATE/)
    {
      $rec->{'ISRDATE'}=1;
      $g_isrdate=1;
      push @{$hrdate{$_}},$_;
      #Case 1.#if RDATEs should be deleted
      if ($deleteRDATE)
      {
        if ($rec->{'ISRRULE'})
        {
          $fdelete =1;
          $g_isdelrdate=1;
        }
      }
    }
    elsif ($_ =~/^ATTENDEE/)
    {
      #check for empty "mailto" and 'mailto' property existence
      #if it is empty or doesnt exists, remove corresponding ATTENDEE
      my $keepmove=1;
      my $tline=$_;
      my $cmptline=$tline;
      my $nomailto=0;
      my $npos;
      my $curpos=tell CFHANDLE;
      while ($keepmove)
      {
        if (($cmptline =~/mailto:/)||($nomailto))
        {
          $keepmove=0;
          if(($cmptline =~/mailto:$/)||($nomailto))
          {
            my $nline;
            if (!$nomailto)
            {
              $npos= tell CFHANDLE;
              $nline = readline(*CFHANDLE);
            }
            else
            {
              $nline = $tline;
            }
            if ($nline=~/ATTENDEE|END/)
            {
              if ($nomailto)
              {
                &log_message("$cmptline");
                &log_message("WARNING: No 'mailto:' found. May cause import error.\n");
              }
              else
              {
                &log_message("$tline");
                &log_message("WARNING: EMPTY 'mailto:' found. May cause import error.\n");
              }
              &log_message("Removing it from output file.");
              $fdelete=1;
              seek CFHANDLE,$npos,0;
              #remove from recdata array else will destroy recurring event.
              my $item = pop(@recdata);
              &log_message("removed from rec array:$item");
            }
            else
            {
              seek CFHANDLE,$curpos,0;
            }
          }
          else
          {
            #check if some part of mailto: is left,
            #if yes, add it before exiting.
            #It will be used to create attendee list (exception creation, if attendees changed!)
            my $iline;
            $npos= tell CFHANDLE;
            $iline = readline(*CFHANDLE);
            if ($iline =~/ATTENDEE|END/)
            {
              #nothing to do here...
            }
            else
            {
              #trim to avoid any start/end spaces
              $iline = trim($iline);
              $cmptline = $cmptline.$iline;
            }
            #create attendee list
            push(@attendeearr,$cmptline);
            #set to startpos
            seek CFHANDLE,$curpos,0;
          }
        }
        else
        {
          $npos= tell CFHANDLE;
          $tline = readline(*CFHANDLE);
          #trim to avoid any start/end spaces
          $tline = trim($tline);
          #form complete ATTENDEE line as 'mailto' may be divided into more than one line
          $cmptline = $cmptline.$tline;
          #globally replace all line-feeds with nothing
          $cmptline =~ s/\n//g;
          #globally replace all carriage-returns with nothing
          $cmptline =~ s/\r//g;
          #if next ATTENDEE or END:VEVENT found, it means no 'mailto' is found!!!.
          if ($tline =~/ATTENDEE|END/)
          {
            $nomailto=1;
          }
        }
      }#end while keepmove
    }
    elsif ($_=~/^END:VEVENT/)         #end of VEVENT
    {
      foreach my $rdate ( sort keys %hrdate)
      {
        &log_message("$rdate \n");
      }
      $rec->{'RDATE'}= {%hrdate};
      $rec->{'RECDATA'} = [@recdata];
      $rec->{'ATTENDEES'} = [@attendeearr];
      push @{$hlist{$rec->{'UID'}}}, $rec;
      %hrdate=();
      $enveventpos=tell CFHANDLE;#remember last vevent end pos
      &log_message("--End VEVENT component.");
    }
    #uniical exports ics file with VCALANDER component for each UID group
    elsif($_=~/^END:VCALENDAR/)
    {
      if (($uidtosrch ne $prvuid)&&(!$g_isdelrdate)&&($g_isrdate))
      {
        $Iscreaterrule=1;
        $uidtosrch=$prvuid;
        $del_pos=$prvrecevpos;
      }
      else
      {
        $prvuid="";
      }
      $g_isdelrdate=0;
      $g_isrdate=0;
      $IsFirstRecId=0;
    }
#Case: 1 *******************************************************>>>>>>>>>>>
    #shall we delete the RDATEs from VEVENT with RRULE and RDATEs?
    #if $fdelete is false, dont include the line
    my $read_pos = tell CFHANDLE;
    seek OTHANDLE, $write_pos, 0;
    if (!$fdelete)
    {
      if (/^DTSTART/)
      {
        my $tzdtst= $_;
        $tzdtst=~ s/DTSTART/DTSTART$TZTag/;
        print_outfile("$tzdtst");
      }
      elsif (/^DTEND/)
      {
        my $tzdten= $_;
        $tzdten=~ s/DTEND/DTEND$TZTag/;
        print_outfile("$tzdten");
      }
      elsif (/^RECURRENCE-ID/)
      {
        my $tzrecid= $_;
        $tzrecid=~ s/RECURRENCE-ID/RECURRENCE-ID$TZTag/;
        print_outfile("$tzrecid");
      }
      #Add METHOD:PUBLISH to avoid NPE during import
      elsif (/^BEGIN:VCALENDAR/)
      {
        print_outfile ($_);
        &Add_METHOD_PUBLISH;
        $write_pos = tell OTHANDLE;
      }
      else
      {
        #write to output file
        print_outfile ($_) ;
      }
    }
    else
    {
      &log_message("Deleting $_");
    }
#End Case:1 *****************************************************<<<<<<<<<

#Case: 2 & Case: 3***********************************************>>>>>>>>>>
    #shall we create new RRULE for RDATEs only VEVENT?
    if ($Iscreaterrule)
    {
      &log_message("Creating event with RRULE....");
      #deletion start position
      my $delstpos= $del_pos;
      #truncate file till delstpos
      seek OTHANDLE, $delstpos, 0;
      truncate OTHANDLE, $delstpos or print "Couldn't truncate: $!\n";
      #reset to last event component
      seek CFHANDLE,$enveventpos,0;
      #get array of recurring events with same UID
      my @newrecarr= @{$hlist{$uidtosrch}};
      my @masterrecdata; my $delta_days; my $rdarray;
      my $masterrec;
      my $RPrulecreated=0; my $checkforltdex=0;
      my $sEvDate=0; my $eEvDate=0;
      my $orig_mstrsdt=0; my $orig_mstredt=0;
      my %srtd_newrecarr=();
      my %ltd_exlist=(); my $lmt_listrec={};
      my $islocchanged=0; my $issmrychanged=0; my $isattndchanged=0;
      my $isrdtimeok=1;my $isdescchanged=0; my $isweekdayok=1;
      my $isrdtdeleted=0;
      #iterate through all occurences
      my %heventdates=();
      foreach my $newrec (@newrecarr)
      {
        #store all events DTSTART and DTEND so that first group date can be extracted
        #to create master VEVENT as master can appear on any group date in some cases.
        push @{$heventdates{$newrec->{'DTSTART'}}},$newrec->{'DTEND'};
        #find master event
        if ($newrec->{'MASTER_VEVENT'})
        {
          $masterrec= $newrec;
        }
        #create sorted hash for recurrences else exceptions are created in random way and cannot be shown in UI
        push @{$srtd_newrecarr{$newrec->{'DTSTART'}}},$newrec;
      }#end foreach my $newrec
      
      &print_srtdnewrecarr(%srtd_newrecarr);
      
      #get first event dates
      my $key;
      foreach $key (sort keys %heventdates)
      {
        $sEvDate = $key;
        $eEvDate= $heventdates{$key}[0];
        last;
      }
        
      #check for nonStandardDTSTART
      if ($nonStandardDTSTART)
      {
        #check if masterrec DTSTART is not equal to oldest RDATE.
        #(29805)if so make oldest RDATE event as master and add master's DTSTART to rdate array.
        if ($masterrec->{'DTSTART'} ne $sEvDate)
        {
          &log_message("WARNING:Masterrec DTSTART is not same as oldest RDATE.icalmig will adopt nonStandardDTSTART.");
          my $mstrdtstart=$masterrec->{'DTSTART'};
          my $mstrdtend=$masterrec->{'DTEND'};

          #srdt_array modifications----->
          #put old masterrec date in least DTSTART containing object
          my $firstrec=$srtd_newrecarr{$sEvDate}[0];
          my $frstrectstartdt= $firstrec->{'DTSTART'};
          my $frstrecenddt=  $firstrec->{'DTEND'};
          #delete it
          delete ($srtd_newrecarr{$firstrec->{'DTSTART'}});
          $firstrec->{'DTSTART'}=$mstrdtstart;
          $firstrec->{'DTEND'}=$mstrdtend;
          
          #put least DTSTART/DTEND in masterrec
          my $newmstrrec= $srtd_newrecarr{$mstrdtstart}[0];
          #delete it
          delete($srtd_newrecarr{$newmstrrec->{'DTSTART'}});
          $newmstrrec->{'DTSTART'}=$frstrectstartdt;
          $newmstrrec->{'DTEND'}=$frstrecenddt;
          
          #push modified instances
          push @{$srtd_newrecarr{$firstrec->{'DTSTART'}}},$firstrec;
          push @{$srtd_newrecarr{$newmstrrec->{'DTSTART'}}},$newmstrrec;
          #srdt_modifications end--------<
          
          #rdarray modifications------->
          my $rdarr;
          $rdarr = ($masterrec->{'RDATE'});
          #delete RDATE
          $frstrectstartdt=~ s/DTSTART/RDATE/;
          delete ($rdarr->{$frstrectstartdt});
          #Add old masterrec date
          $mstrdtstart=~ s/DTSTART/RDATE/;
          push @{$rdarr->{$mstrdtstart}},$mstrdtstart;
          &print_srtdnewrecarr(%srtd_newrecarr);
        }
      }
      #will remove any RDATE occurences which are before master even DTSTART
      elsif($StandardDTSTART)
      {
        #(29743)for making it RFC compliant, make masterrec as start event and delete older rdates from rdate array.
        if ($masterrec->{'DTSTART'} ne $sEvDate)
        {
          my $mstrdtstart=$masterrec->{'DTSTART'};
          $mstrdtstart=~ s/DTSTART/RDATE/;
          my $rdarr;
          $rdarr = ($masterrec->{'RDATE'});
          for my $key ( sort keys %$rdarr)
          {
            if($key lt $mstrdtstart)
            {
              delete ($rdarr->{$key});
              my $tdtdst= $key;
              $tdtdst=~ s/RDATE/DTSTART/;
              delete($srtd_newrecarr{$tdtdst});
              $isrdtdeleted=1;
            }
          }#end for
        }#end if
      }#end else


      #Create master event
      if ($masterrec->{'MASTER_VEVENT'})
      {
        &log_message("Creating master event. UID:$masterrec->{'UID'}");
        #create master VEVENT with all data as it is except RADTEs and
        #create new RRULE section
        @masterrecdata= @{$masterrec->{'RECDATA'}};
        my $isrruledone=0;
        my $IsfirstRdate=1; my $firstrdate=0; my $lastrdate=0;
        my $val;
        #write MasterEvent properties and modify needed values
        for(my $i=0; $i<$#masterrecdata+1; $i++)
        {
          my $str=$masterrecdata[$i];
          #if RDATE; calculate RDATE range and create RRULE with
          #exceptions for same dates
          if ($str =~/^RDATE/)
          {
            &log_message("Removed: $str");
            if (!$isrruledone)
            {
              #if RRULE should be created on recurrence pattern
              if ($createPatternRRULE)
              {
                my $dlctr=0;my $wkctr=0; my $bwkctr=0;
                $rdarray= ($masterrec->{'RDATE'});
                #Add master date too in rdarray for pattern calculation.
                #It WILL be removed after pattern calculation
                my $tmdts= $masterrec->{'DTSTART'};
                $tmdts=~ s/DTSTART/RDATE/;
                push @{$rdarray->{$tmdts}},$tmdts;

                #get master weekday;Will be used to check for RDATE weekdays.
                #if master weekday is not same as RDATE weekdays, create exceptions.
                #As it is possible that recurrence has been changed to another weekday
                #later.
                my $midx= rindex($masterrec->{'DTSTART'},':');
                my $mdt= substr($masterrec->{'DTSTART'},$midx+1);
                my $masterweekday=get_weekday($mdt);
                
                #get time difference of rdate appointments, if time is different
                #create exceptions else only RRULE will create recurrence only
                #on base of master event
                my $msttime=$mdt;
                
                #store masterrect location to check with occurence's location,
                #if changed, exception should be cerated
                my $mlocation= $masterrec->{'LOCATION'};
                
                #store masterrec summary to check with occurence's summary,
                #if changed, exception should be cerated
                my $msummary= $masterrec->{'SUMMARY'};
                
                #store attendee to check with occurrence's attendee list,
                #if changed, exception should be created
                my @mattendeearr= @{$masterrec->{'ATTENDEES'}};
                
                #store description to check with occurrence's description,
                #if changed, exception should be created
                my $mdescription= $masterrec->{'DESCRIPTION'};
                
                my $k1;my $k2;my $v1; my $v2;
                my $rweekday;
                my $ioccurrec; my $ilocation;my $isummary;my @iattenarr;my $idescription;
                my $floop=1;
                my $sdt;my $ndt;
                my $isweekendpresent=0; my $wkday; my $weekendcount=0;
                my $prvwkday=0;my $jstcrosswend=0;
                for my $k1 ( sort keys %$rdarray )
                {
                  my $twdidx= rindex($k1,':');
                  my $tk1= substr($k1,$twdidx+1);
                  $wkday= get_weekday($tk1);
                  #check if weekend present
                  if ($wkday>5)
                  {
                    #yes it is there!
                    $isweekendpresent=1;
                  }
                  if ($prvwkday>$wkday)
                  {
                    $weekendcount++;
                    $jstcrosswend=1;
                  }
                  $prvwkday=$wkday;
                  if ($floop)  #first loop
                  {
                    $k2=$k1;
                    $firstrdate=$k1;
                    $lastrdate=$k1;
                    $sdt= $k2;
                    $ndt=$k1;
                    $floop=0;
                  }
                  else
                  {
                    $sdt= $k2;
                    $ndt=$k1;
                    my $rsdt= $sdt;
                    $rsdt=~ s/RDATE/DTSTART/;
                    $ioccurrec=$srtd_newrecarr{$rsdt}[0];
                    $ilocation= $ioccurrec->{'LOCATION'};
                    $isummary = $ioccurrec->{'SUMMARY'};
                    @iattenarr = @{$ioccurrec->{'ATTENDEES'}};
                    $idescription= $ioccurrec->{'DESCRIPTION'};
                    my $tidx= rindex($sdt,':');
                    $sdt= substr($sdt,$tidx+1);
                    $ndt = substr($ndt,$tidx+1);
                    #check for rdate weekdays
                    $rweekday= get_weekday($sdt);
                    #if master weekday is not same as RDATE weekday
                    if ($masterweekday != $rweekday)
                    {
                      $isweekdayok=0;
                      $ltd_exlist{$rsdt}=1;
                    }
                    
                    #check for if master date time is equal to rdate time component
                    my $rsttime= $sdt;
                    if (!istime_equal($msttime,$sdt))
                    {
                      $isrdtimeok = 0;
                      $ltd_exlist{$rsdt}=0;
                      &log_message("occurrence time changed->master-time:$msttime recur-time:$rsttime");
                    }
                    #if location changed, create exceptions
                    if ($mlocation ne $ilocation)
                    {
                      $islocchanged=1;
                      $ltd_exlist{$rsdt}=0;
                      &log_message("occurrence location changed->master-location:$mlocation recur-location:$ilocation");
                    }
                    #if summary changed, create exceptions
                    if ($msummary ne $isummary)
                    {
                      $issmrychanged=1;
                      $ltd_exlist{$rsdt}=0;
                      &log_message("occurrence summary changed->master-summary:$msummary recur-summary:$isummary");
                    }
                    #if attendees changed, create exception
                    if ($#iattenarr eq $#mattendeearr)
                    {
                      for(my $j=0; $j<$#iattenarr+1; $j++)
                      {
                        if ($iattenarr[$j] ne $mattendeearr[$j])
                        {
                          $isattndchanged=1;
                          $ltd_exlist{$rsdt}=0;
                          &log_message("occurrence attendees changed \nmaster-attendees:@mattendeearr \nrecur-attendee:@iattenarr");
                        }
                      }
                    }
                    else
                    {
                      $isattndchanged=1;
                      $ltd_exlist{$rsdt}=0;
                      &log_message("occurrence attendees changed \nmaster-attendees:@mattendeearr \nrecur-attendee:@iattenarr");
                    }
                    #if description changed, create exceptions
                    if ($mdescription ne $idescription)
                    {
                      $isdescchanged=1;
                      $ltd_exlist{$rsdt}=0;
                      &log_message("occurrence description changed->master-summary:$mdescription recur-summary:$idescription");
                    }
                    
                    #delta days
                    $delta_days=get_date_diff($sdt, $ndt);
                    if (($delta_days==$DAILY)||(($jstcrosswend)&&($delta_days eq 3)))
                    {
                      $dlctr++;
                      &log_message("Delta: DAILY");
                    }
                    elsif($delta_days==$WEEKLY)
                    {
                      $wkctr++;
                      &log_message("Delta: WEEKLY");
                    }
                    elsif($delta_days==$BIWEEKLY)
                    {
                      $bwkctr++;
                      &log_message("Delta: BIWEEKLY");
                    }
                    $k2=$k1;
                    $lastrdate=$k1;
                    print "$delta_days";
                    $jstcrosswend=0;
                  }
                } #end for my $k1...
                
                #check for last occurrence
                #***************************
                my $rndt= $lastrdate;
                $rndt=~ s/RDATE/DTSTART/;
                $ioccurrec=$srtd_newrecarr{$rndt}[0];
                my $tidx= rindex($ndt,':');
                $ndt = substr($ndt,$tidx+1);
                $rweekday= get_weekday($ndt);
                #if master weekday is not same as ndt weekday
                if ($masterweekday != $rweekday)
                {
                  $isweekdayok=0;
                  $ltd_exlist{$rndt}=1;
                }
                #check for if master date time is equal to rdate time component
                if (!istime_equal($msttime,$ndt))
                {
                  $isrdtimeok = 0;
                  $ltd_exlist{$rndt}=0;
                  log_message("occurrence time changed->master-time:$msttime recur-time:$ndt");
                }
                #Get summary and location information
                $ilocation= $ioccurrec->{'LOCATION'};
                $isummary = $ioccurrec->{'SUMMARY'};
                @iattenarr = @{$ioccurrec->{'ATTENDEES'}};
                $idescription= $ioccurrec->{'DESCRIPTION'};
                #if location changed, create exceptions
                if ($mlocation ne $ilocation)
                {
                  $islocchanged=1;
                  $ltd_exlist{$rndt}=0;
                  &log_message("occurrence location changed->master-location:$mlocation recur-location:$ilocation");
                }
                #if summary changed, create exceptions
                if ($msummary ne $isummary)
                {
                  $issmrychanged=1;
                  $ltd_exlist{$rndt}=0;
                  &log_message("occurrence summary changed->master-summary:$msummary recur-summary:$isummary");
                }
                #if attendees changed, create exception
                if ($#iattenarr eq $#mattendeearr)
                {
                  for(my $j=0; $j<$#iattenarr+1; $j++)
                  {
                    if ($iattenarr[$j] ne $mattendeearr[$j])
                    {
                      $isattndchanged=1;
                      $ltd_exlist{$rndt}=0;
                      &log_message("occurrence attendees changed \nmaster-attendees:@mattendeearr \n recur-attendee:@iattenarr");
                    }
                  }
                }
                else
                {
                  $isattndchanged=1;
                  $ltd_exlist{$rndt}=0;
                  &log_message("occurrence attendees changed \nmaster-attendees:@mattendeearr \n recur-attendee:@iattenarr");
                }
                #if description changed, create exceptions
                if ($mdescription ne $idescription)
                {
                  $isdescchanged=1;
                  #push @{$ltd_exlist{$rndt}},0;
                  $ltd_exlist{$rndt}=0;
                  &log_message("occurrence description changed->master-summary:$mdescription recur-summary:$idescription");
                }
                #***************************
                #delete master dtstart from rdarray which was added for pattern
                #calculation before
                delete($rdarray->{$tmdts});
                
                my $rdpattern=0; my $freq; my $interval; my $rdcnt;
                $rdcnt= keys (%$rdarray);#-1;
                if (!$rdcnt)
                {
                  $rdcnt++;
                }
                my $pmatch= ($dlctr/$rdcnt)*100; #DAILY
                &log_message("DAILY Match Percentage: $pmatch");
                if ($pmatch<$MATCHPC)
                {
                  $pmatch= ($wkctr/$rdcnt)*100;  #WEEKLY
                  &log_message("WEEKLY Match Percentage: $pmatch");
                  if($pmatch<$MATCHPC)
                  {
                    $pmatch= ($bwkctr/$rdcnt)*100; #BIWEEKLY
                    &log_message("BIWEEKLY Match Percentage: $pmatch");
                    if($pmatch<$MATCHPC)
                    {
                    }
                    else
                    {
                      $rdpattern=$BIWEEKLY;
                      $freq="WEEKLY";
                      $interval=2;
                    }
                  }
                  else
                  {
                    $rdpattern=$WEEKLY;
                    $freq="WEEKLY";
                    $interval=1;
                  }
                }
                else
                {
                  $rdpattern=$DAILY;
                  $freq="DAILY";
                  $interval=1;
                  #reset isweekok as in case of DAILY frequency, weekdays will
                  #be always different.
                  $isweekdayok=1;
                }
                &log_message("Total RDATEs: $rdcnt DailyCtr: $dlctr WeeklyCtr: $wkctr");

                #### Exception/RRULE creation criteria ####
                #1. if recurrence pattern found, No need to create exceptions
                #2. if weekdays has changed due to meeting has moved to another day,
                #   create complete series exception.
                if ($rdpattern)
                    #&& ($isweekdayok))
                    #&& ($isrdtimeok)
                    #&& (!$islocchanged) &&(!$issmrychanged) &&(!$isattndchanged)
                    #&& (!$isdescchanged))
                {
                  if ($freq eq "DAILY")
                  {
                    #create RRULE for exceptions
                    my $ridx= rindex($firstrdate,':');
                    if($ridx<0)
                    {
                      &log_message("No expected(:) delimiter found.Qutiing!!!") ;
                      die "No expected(:) delimeter found. Quitting!!!";
                    }
                    my $fdt= substr($firstrdate,$ridx+1);
                    my $ldt = substr($lastrdate,$ridx+1);
                    #delta days
                    #if weekdays present, take complete day difference
                    if($isweekendpresent)
                    {
                      $delta_days=get_date_diff($fdt, $ldt)+1;
                    }
                    else#else deduct weekends
                    {
                      $delta_days=get_date_diff($fdt, $ldt)+1;
                      $delta_days = $delta_days - ($weekendcount*2);
                    }
                  }
                  else
                  {
                    $delta_days=$rdcnt+1;
                  }
                  my $bywkday=";BYDAY=MO,TU,WE,TH,FR";
                  my $newrrule= "RRULE:FREQ=$freq;COUNT=$delta_days;INTERVAL=$interval";
                  if(($freq eq "DAILY")&&(!$isweekendpresent))
                  {
                    #set it to weekly to avoid server side bug#30094
                    $newrrule= "RRULE:FREQ=WEEKLY;COUNT=$delta_days;INTERVAL=$interval".$bywkday;
                  }
                  print_outfile("$newrrule");
                  &log_message("New RRULE: $newrrule.");
                  $RPrulecreated=1;
                  $checkforltdex=1;
                }
              }#end_if($createPatternRRULE)

              #if recurrence pattern based RRULE could NOT be created
              #Go for RRULE for exceptions
              if(!$RPrulecreated)
              {
                #create RRULE for exceptions
                my $ridx= rindex($firstrdate,':');
                if($ridx<0)
                {
                  &log_message("No expected(:) delimiter found.Qutiing!!!") ;
                  die "No expected(:) delimeter found. Quitting!!!";
                }
                my $fdt= substr($firstrdate,$ridx+1);
                my $ldt = substr($lastrdate,$ridx+1);
                #delta days
                $delta_days=get_date_diff($fdt, $ldt)+1;
                my $reccnt=keys(%$rdarray)+1;
                my $newrrule= "RRULE:FREQ=YEARLY;COUNT=$reccnt;INTERVAL=1";
                print_outfile("$newrrule");
                &log_message("New RRULE: $newrrule.");
                $checkforltdex=0;
              }
            }#end if (!$isrruledone)
            $isrruledone=1;
          }
          elsif ($str =~/^DTSTART/)
          {
            my $tzdtst;
            if($isrdtdeleted)
            {
              $tzdtst=$str;
            }
            else
            {
              $tzdtst= $sEvDate;
            }
            $orig_mstrsdt=$str;
            $tzdtst=~ s/DTSTART/DTSTART$TZTag/;
            print_outfile("$tzdtst");
            &log_message("New DTSTART: $tzdtst");
          }
          elsif ($str =~/^DTEND/)
          {
            my $tzdten;
            if($isrdtdeleted)
            {
              $tzdten=$str;
            }
            else
            {
              $tzdten= $eEvDate;#$str;
            }
            $orig_mstredt=$str;
            $tzdten=~ s/DTEND/DTEND$TZTag/;
            print_outfile("$tzdten");
            &log_message("$tzdten");
          }
          else  #keep writing in Outfile
          {
            print_outfile("$str");
          }
        }#end writing masterrecdata--creating master event with RRULE
        &log_message("Master event created.");
      }#end ($$masterrec->{'MASTER_VEVENT'})

      #if pattern has found and any of following is changed. Create exception
      #only for changed occurences else exceptions will be created for complete series.
      #1. if time has changed for RDATE occurences.
      #2. if LOCATION changed for any occurrence.
      #3. if SUMMARY changed for any occurences.
      #4. if ATTENDEE list changed for any occurrence.
      #5. if DESCRIPTION changed for any occurrence.
      if (($checkforltdex)&& ((!$isrdtimeok)
          || ($islocchanged) ||($issmrychanged)
          || ($isattndchanged) || ($isdescchanged)
          || ($isweekdayok)))
      {
        &log_message("Checking limited exception occurrences");
        my $recidfmtstr="";
        my $recctr=1;
        my $mstrdtstart = $masterrec->{'DTSTART'};
        my $ndtstart=$mstrdtstart;
        my $idx2= index($mstrdtstart,';');
        my $ridx= rindex($mstrdtstart,':');
        my $recidfmtstr="";
        if ($idx2>0)
        {
          $recidfmtstr=substr($mstrdtstart,$idx2,($ridx-$idx2)+1);
        }
        else
        {
          $recidfmtstr=":";
        }
        $mstrdtstart = substr($mstrdtstart,$ridx+1);
        my $ndtstart=$mstrdtstart;
        my $syear= substr($ndtstart,0,4);

        foreach my $srdtkey (sort keys %ltd_exlist)
        {
          my $wdc =$ltd_exlist{$srdtkey};
          my $ctoccurrence=1;
          #if only weekday changed and weekdays are OK then skip it.
          if (($wdc ==1)&&($isweekdayok))
          {
            $ctoccurrence=0;
          }
          if ($ctoccurrence)
          {
            my $occurrec=$srtd_newrecarr{$srdtkey}[0];
            #only for recurrences
            if (!$occurrec->{'MASTER_VEVENT'})
            {
              &log_message("Creating limited Recurrence:");
              my @occurrecdata= @{$occurrec->{'RECDATA'}};
              for(my $i=0; $i<=$#occurrecdata; $i++)
              {
                my $str=$occurrecdata[$i];

                if ($str =~/^DTSTART/)
                {
                  my $tzdtst= $str;
                  $tzdtst=~ s/DTSTART/DTSTART$TZTag/;
                  print_outfile("$tzdtst");
                  &log_message("New DTSATRT:$tzdtst");
                }
                elsif ($str =~/^DTEND/)
                {
                  my $tzdten= $str;
                  $tzdten=~ s/DTEND/DTEND$TZTag/;
                  print_outfile("$tzdten");
                  &log_message("New DTEND: $tzdten");
                }
                elsif($str =~/^RECURRENCE-ID/)
                {
                  my $rndtt; my $rntime;
                  if(!$isrdtimeok)
                  {
                    $rndtt=$occurrec->{'DTSTART'};
                    $rndtt=~ s/DTSTART$recidfmtstr//;
                    $rndtt=get_date($rndtt);
                    $rntime = get_time($ndtstart);
                    $rndtt= "RECURRENCE-ID$TZTag$recidfmtstr$rndtt"."T$rntime";
                  }
                  else
                  {
                    $rndtt= $str;
                    $rndtt=~ s/RECURRENCE-ID/RECURRENCE-ID$TZTag/;
                  }
                  print_outfile("$rndtt");
                }
                elsif($str =~/^CREATED/)
                {
                 #do nothing
                }
                elsif ($str =~/^UID/)
                {
                  #for log purpose only
                  &log_message("$str");
                  print_outfile("$str");
                }
                else
                {
                  print_outfile("$str");
                }
              }# end_for(my $i=0...)
              &log_message("Limited recurrence Created.");
            }#end_if (!$occurrec->{'MASTER_VEVENT'})
          }
        }#end_foreach my $srdtkey
        $begreceventpos= tell OTHANDLE;
        &log_message("Check for limited Recurrences finished.");
        $RPrulecreated=1;
      }

      #if RRULE for exceptions created, create recurrences
      if(!$RPrulecreated)
      {
        &log_message("Creating Recurrences...");
        my $recctr=1;
        #get last datetime portion
        $rdarray = ($masterrec->{'RDATE'});
        my $mstrdtstart = $masterrec->{'DTSTART'};
        my $idx2= index($mstrdtstart,';');
        my $ridx= rindex($mstrdtstart,':');
        my $recidfmtstr="";
        if ($idx2>0)
        {
          $recidfmtstr=substr($mstrdtstart,$idx2,($ridx-$idx2)+1);
        }
        else
        {
          $recidfmtstr=":";
        }
        $mstrdtstart = substr($mstrdtstart,$ridx+1);
        my $ndtstart=$mstrdtstart;
        my $syear= substr($ndtstart,0,4);

        foreach my $srdtkey (sort keys %srtd_newrecarr)
        {
          my $occurrec=$srtd_newrecarr{$srdtkey}[0];
          #only for recurrences
          if (!$occurrec->{'MASTER_VEVENT'})
          {
            &log_message("Creating Recurrence:");
            my @occurrecdata= @{$occurrec->{'RECDATA'}};
            for(my $i=0; $i<=$#occurrecdata; $i++)
            {
              my $str=$occurrecdata[$i];
            
              if ($str =~/^DTSTART/)
              {
                #create RECURRENCE-ID
                #it should be increment to masterevent's DTSTART
                #and continue for range need to cover
                #increment by year as Outlook cannot show exceptions, if
                #recurrecneID is less than the DTSTART
                $syear++;
                $ndtstart= $syear.substr($ndtstart,4);
                #$ndtstart= get_date_by_days($ndtstart,$dyinyr); #for yearly increment
                my $rndtstart= "RECURRENCE-ID$TZTag$recidfmtstr$ndtstart";
                print_outfile("$rndtstart");
                &log_message("New RECURRENCE-$rndtstart");
                $recctr++;
              
                #start date
                #if RDATEs are not in sequence than master date shifts to first
                #date(RDATE) so master original date should appear as RDATE.
                if ($sEvDate eq $str)
                {
                  $str=$orig_mstrsdt;
                }
                my $tzdtst= $str;
                $tzdtst=~ s/DTSTART/DTSTART$TZTag/;
                print_outfile("$tzdtst");
                &log_message("New DTSATRT:$tzdtst");
              }
              elsif ($str =~/^DTEND/)
              {
                if ($eEvDate eq $str)
                {
                  $str=$orig_mstredt;
                }
                my $tzdten= $str;
                $tzdten=~ s/DTEND/DTEND$TZTag/;
                print_outfile("$tzdten");
                &log_message("New DTEND: $tzdten");
              }
              elsif($str =~/^RECURRENCE-ID/)
              {
                &log_message("Old Recurrence-Id: $str");
                #do nothing as we create REC-ID with DTSTART
              }
              elsif($str =~/^CREATED/)
              {
                #do nothing
              }
              elsif ($str =~/^UID/)
              {
                #for log purpose only
                &log_message("$str");
                print_outfile("$str");
              }
              else
              {
                print_outfile("$str");
              }
            }
            &log_message("Recurrence Created.");
          }
        }
        $begreceventpos= tell OTHANDLE;
        &log_message("All Recurrences Created.");
      }

      $Iscreaterrule=0;
      #next write position
      $write_pos = tell OTHANDLE;
      $begreceventpos= tell OTHANDLE;
      $wasrulecreated=1;
    }
    else
    {
      $write_pos = tell OTHANDLE;
      seek CFHANDLE, $read_pos, 0;
      $fdelete=0;
    }
#END Case 2: ***************************************************<<<<<<<<<<<<

  } #end while<CFHANDLE>
  
  &log_message("processing finished");
  return %hlist;
}

#get date by adding days into date
sub get_date_by_days
{
  my $tdate= @_[0];
  my $tdays = @_[1];
  
  my @darr = split(/T/, $tdate);
  my $tdt= $darr[0];
  my $yr= substr($tdt,0,4);
  my $mm= substr($tdt,4,2);
  my $dd= substr($tdt,6,2);

  (my $y2, my $m2, my $d2)= Add_Delta_Days($yr,$mm,$dd, $tdays);
  my $newdt  = sprintf("%d%02d%02d", $y2, $m2, $d2);
  if($darr[1])
  {
    $newdt = $newdt.'T'.$darr[1];
  }
  return $newdt;
}

#takes dates in yyyymmdd/yyyymmddThhmmss format and return number of days
sub get_date_diff
{
  #format: 20070302T153000Z, 20070406
  #check for Timezone format, presence of T
  my $fd=@_[0];
  my $ld=@_[1];
  my @darr = split(/T/, $fd);
  my $stdate= $darr[0];
  @darr =();
  @darr = split(/T/, $ld);
  my $endate= $darr[0];
  my $yr1= substr($stdate,0,4);
  my $mm1= substr($stdate,4,2);
  my $dd1= substr($stdate,6,2);

  my $yr2= substr($endate,0,4);
  my $mm2= substr($endate,4,2);
  my $dd2= substr($endate,6,2);
  my @date1 = ($yr1, $mm1, $dd1);
  my @date2  = ($yr2, $mm2, $dd2);
  
  my $diff = &Delta_Days(@date1, @date2);
  
  return $diff;
}

#Input format: 20070302T153000Z, 20070406
#returns Week Day
sub get_weekday
{
  my $dt=shift;
  my @darr = split(/T/, $dt);
  $dt= $darr[0];
  my $yr1= substr($dt,0,4);
  my $mm1= substr($dt,4,2);
  my $dd1= substr($dt,6,2);
  my $dow=Day_of_Week($yr1,$mm1,$dd1);
  my $tdow = Day_of_Week_to_Text($dow);
  log_message("Weekday: $dow - $tdow");
  return $dow;
}

#Input format 20070302T153000Z, 20070406
#Compare 2 date-time components for eqality
sub istime_equal
{
  my $tm=shift;
  my @tarr = split(/T/, $tm);
  my $dt= $tarr[1];
  my $hr1= substr($dt,0,2);
  my $mn1= substr($dt,2,2);
  my $ss1= substr($dt,4,2);
  
  $tm=shift;
  @tarr= split(/T/, $tm);
  $dt= $tarr[1];
  my $hr2= substr($dt,0,2);
  my $mn2= substr($dt,2,2);
  my $ss2= substr($dt,4,2);
  if(($hr1==$hr2)&&($mn1==$mn2)&&($ss1==$ss2))
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

#Input format 20070302T153000Z, 20070406
#returns DATE part
sub get_date
{
  my $dt=shift;
  my @darr = split(/T/, $dt);
  $dt= $darr[0];
  return $dt;
}

#Input format 20070302T153000Z, 20070406
#returns TIME part
sub get_time
{
  my $tm=shift;
  my @darr = split(/T/, $tm);
  $tm= $darr[1];
  return $tm;
}


sub print_outfile
{
  my $str=@_[0];
  chomp($str);
  print OTHANDLE "$str\n";
}

sub print_invalidfile
{
  my $str=@_[0];
  chomp($str);
  print IVHANDLE "$str\n";

}
#test function
#input param: hash list
sub print_hlist
{
  my %tmphlist = @_;
  foreach my $uid ( sort keys %tmphlist)
  {
    &log_message("$uid");
    foreach my $rec ( @{$tmphlist{$uid}} )
    {
      if ($rec->{'MASTER_VEVENT'})
      {
        &log_message("MASTER VEVENT");
        my $rdarr= $rec->{$uid}{'RDATE'};
        for my $trdate (@$rdarr)
        {
          &log_message("RDATEs: $trdate");
        }
      }
      &log_message("    $rec->{'RECURRENCE-ID'}");
    }
  }
}

#test function
sub print_srtdnewrecarr
{
  my %tmphlist = @_;
  foreach my $srdate ( sort keys %tmphlist)
  {
    &log_message("$srdate");
  }
}

# trim function to remove whitespace from the start and end of the string
sub trim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;
}
# Left trim function to remove leading whitespace
sub ltrim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	return $string;
}
# Right trim function to remove trailing whitespace
sub rtrim($)
{
	my $string = shift;
	$string =~ s/\s+$//;
	return $string;
}

#TimeZone information header for EST5EDT
sub init_TZHeader
{
  @TZHeader =(
  "BEGIN:VTIMEZONE",
  "TZID:EST5EDT",
  "BEGIN:DAYLIGHT",
  "RRULE:FREQ=YEARLY;UNTIL=20750314T020000Z;BYMONTH=3;BYDAY=2SU",
  "TZNAME:Eastern Standard Time\, Eastern Daylight Time",
  "TZOFFSETTO:-0400",
  "TZOFFSETFROM:-0500",
  "DTSTART:20070308T020000",
  "END:DAYLIGHT",
  "BEGIN:STANDARD",
  "RRULE:FREQ=YEARLY;UNTIL=20751107T020000Z;BYMONTH=11;BYDAY=1SU",
  "TZNAME:Eastern Standard Time\, Eastern Daylight Time",
  "TZOFFSETTO:-0500",
  "TZOFFSETFROM:-0400",
  "DTSTART:20071101T020000",
  "END:STANDARD",
  "BEGIN:DAYLIGHT",
  "RRULE:FREQ=YEARLY;UNTIL=20060407T020000Z;BYMONTH=4;BYDAY=1SU",
  "TZNAME:Eastern Standard Time\, Eastern Daylight Time",
  "TZOFFSETTO:-0400",
  "TZOFFSETFROM:-0500",
  "DTSTART:19910401T020000",
  "END:DAYLIGHT",
  "BEGIN:STANDARD",
  "RRULE:FREQ=YEARLY;UNTIL=20061031T020000Z;BYMONTH=10;BYDAY=-1SU",
  "TZNAME:Eastern Standard Time\, Eastern Daylight Time",
  "TZOFFSETTO:-0500",
  "TZOFFSETFROM:-0400",
  "DTSTART:19911025T020000",
  "END:STANDARD",
  "END:VTIMEZONE"
  );
  $TZTag= ";TZID=EST5EDT";
}
sub Add_TZHeader
{
  my $i;
  for($i=0;$i <= $#TZHeader;$i++)
  {
    print_outfile("$TZHeader[$i]");
  }
}

sub Add_METHOD_PUBLISH
{
  print_outfile("METHOD:PUBLISH");
}
