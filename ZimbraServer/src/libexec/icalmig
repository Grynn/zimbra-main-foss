#!/usr/bin/perl
#
# ***** BEGIN LICENSE BLOCK *****
#
# Zimbra Collaboration Suite Server
# Copyright (C) 2007-2008 Zimbra, Inc.
#
# The contents of this file are subject to the Yahoo! Public License
# Version 1.0 ("License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://www.zimbra.com/license.
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
#
# ***** END LICENSE BLOCK *****
#
#Convert Oracle Corporate Time iCal file to Zimbra adoptable format
#
use Cwd;
use Date::Calc qw(:all);
use strict;
my $DEBUG = 0;
#global constants
my $version = "1.20";
my $newfileext=".zimbra";
my $bakfileext=".bak";
my $invalidfileext=".invalid";
my @TZHeader;
my $TZTag="";

#get script directory
my $progdir = cwd;
#keep log file in script directory
my $logfilepath;
if ($DEBUG)
{
  $logfilepath="c:\\opt\\zimbra\\log";
}
else
{
  $logfilepath="/opt/zimbra/log";
}
my $logfilename = "icalmig.log";
my $logfile;
my $icalfile;
my $invalidfile;
#used for debug purpose
$icalfile="" if ($DEBUG);

my $outfile;

#used as const values for pattern calcualtions.
my $DAILY = 1,
my $WEEKLY = 7,
my $BIWEEKLY=14,
my $MONTHLY=28,
my $MATCHPC=90,

#default values
#set 1 to delete RDATEs else 0 for no delete
my $deleteRDATE=1;
#set 1 to create exceptions else 0
my $createEXCEPTIONS=1;
#set 1 to create pattern rule else 0
my $createPatternRRULE =1;
#set 1 to use TZ companent and TZ tag else 0
my $useTZcomponent =0;
#over write original file
my $oworginalfile=0;
#for non standard DTSTART (29805)
my $nonStandardDTSTART=0;
# for standard DTSTART(29743)
my $StandardDTSTART=1;

if ($#ARGV<0)
{
  help() if (!$DEBUG);
  exit if (!$DEBUG);
}

#look for command line switches
while ($ARGV[0] =~ /^-(.+)/)
{
  my $switch = $1;
  #pull this switch off of the front of the list
  shift;

  #if they ask for help, do it and exit
  if (($switch eq "h")||($switch eq "help"))
  {
    help();
    exit;
  }
  elsif ($switch eq "v")
  {
    print "VERSION: $version\n";
    exit;
  }
  elsif ($switch eq "f")
  {
    $icalfile = shift;
  }
  elsif ($switch eq "delrdate")
  {
    $deleteRDATE = shift;
  }
  elsif ($switch eq "exceptions")
  {
    $createEXCEPTIONS = shift;
  }
  elsif ($switch eq "patternrule")
  {
    $createPatternRRULE = shift;
  }
  elsif ($switch eq "tz")
  {
    $useTZcomponent = shift;
  }
  elsif ($switch eq "logpath")
  {
    $logfilepath= shift;
  }
  elsif (lc($switch) eq lc("nonStandardDTSTART"))
  {
    $nonStandardDTSTART=1;
  }
  elsif (lc($switch) eq lc("StandardDTSTART"))
  {
    $StandardDTSTART=1;
  }
  else
  {
    print "\nNo such option '$switch'.\n\n";
    help();
    exit;
  }
}
#call functions
&Initialize (@ARGV);
my %rhlist= &processfile;
#&print_hlist(%rhlist);
&UnInitialize;

#help menu
sub help
{
  print "Usage: icalmig -f <ics file> [options]\n";
  print "[options]\n";
  print "-h           (Shows help)  \n";
  print "-v           (Shows Version)\n";
  print "-delrdate    (0-OFF 1-ON ) (DEFAULT: 1)\n";
  print "-exceptions  (0-OFF 1-ON ) (DEFAULT: 1)\n";
  print "-patternrule (0-OFF 1-ON ) (DEFAULT: 1)\n";
  print "-tz          (0-OFF 1-ON ) (DEFAULT: 0)\n";
  print "-nonStandardDTSTART        (Default: 0)\n";
  print "-logpath <path>            (Default /opt/zimbra/log)\n";
  print "\n";
  
}
#Initialize: open logfile and iCal file for parsing
sub Initialize
{
  $logfile= $logfilepath."\/".$logfilename;
  $invalidfile= "$icalfile"."$invalidfileext";
  if (!$icalfile)
  {
    &log_message("No file to process, use -f option.\n");
    exit;
  }
  &log_message("Opening $icalfile...");
  open CFHANDLE, "<$icalfile" or die "Cannot open $icalfile for read :$!";
  &log_message("$icalfile opened successfully.");
  
  #check for log file path (specially for Windows OS)
  my $createdir="mkdir -p $logfilepath";
  if (-d $logfilepath)
  {
    &log_message("$logfilepath exists\n");
  }
  else
  {
    &log_message("mkdir failed\n") unless system($createdir);
  }
  
  #open logfile
  open LFHANDLE, ">$logfile" or die "Cannot open logfile $logfile";
  #open Output file
  $outfile="$icalfile"."$newfileext";
  open OTHANDLE, ">$outfile" or die "can not open output file.";
  #init TZHeader
  &init_TZHeader if $useTZcomponent;
  &log_message("icalmig verison: $version");
}

#unInitialize: close logfile and ical file
sub UnInitialize
{
  #close file handles
  close CFHANDLE;
  close OTHANDLE;
  #close IVHANDLE;
  &log_message("$icalfile and $logfile closed.");
  close LFHANDLE;
  #save original file as bakupfile
  if ($oworginalfile)
  {
    rename($icalfile, $icalfile.$bakfileext);
    rename($outfile, $icalfile);
  }
  &log_message("\n");
  &log_message("*************************************************************");
  &log_message("NOTE:Output file path:$outfile.");
  &log_message("NOTE:Log file path:$logfile.");
  &log_message("*************************************************************");
}

#log_message: log message to file and print to console
sub log_message
{
  my $msg = @_[0];
  chomp($msg);
  print "$msg\n";
  print LFHANDLE "$msg\n";
}

#processfile: do Ical file processing
sub processfile
{
  my $fdelete=0;
  my %hlist=();
  my $rec={};
  my $write_pos = 0;
  my $IsFirstRecId=0;
  my $begreceventpos=0;
  my $prvrecevpos=0;
  my $Iscreaterrule=0;
  my @recdata=();
  my $IsTZHeaderPrinted=0;
  my %hrdate=();
  my $prvuid="";
  my $uidtosrch;
  my $enveventpos=0;
  my $g_isdelrdate=0;
  my $g_isrdate=0;
  my $del_pos=0;
  my $gen_evenstpos=0;
  my $gen_CFsteventpos=0;
  my $wasrulecreated=0;
  my @attendeearr=();
  my $firstevchkctr=0;
  my $IsfrstevStandalone=0; my $frstevdelpos=0; my $uidchangectr=0;
  &log_message("processing file...");
  while (<CFHANDLE>)
  {
    push (@recdata,$_);
    if ($_=~/^BEGIN:VEVENT/)          #start of VEVENT
    {
      #print TZHeader before first VEVENT
      if (($useTZcomponent)&&(!$IsTZHeaderPrinted))
      {
        &log_message("Add TimeZoneHeader.");
        &Add_TZHeader;
        $write_pos = tell OTHANDLE;
        $IsTZHeaderPrinted=1;
      }
      &log_message("Start VEVENT component.");
      $rec={};

      @recdata=();#initialize array
      @attendeearr=();
      push (@recdata,$_);
      
      #set to default value
      $rec->{'MASTER_VEVENT'}=1;
      $rec->{'ISRRULE'}=0;
      $rec->{'ISRDATE'}=0;

      if (!$IsFirstRecId)
      {
        $prvrecevpos =$begreceventpos;
        $begreceventpos= tell OTHANDLE;#remember first rec-id vevent begin pos
        $IsFirstRecId=1;
      }
      $gen_evenstpos= tell OTHANDLE;#generic event start pos
      $gen_CFsteventpos = tell CFHANDLE;#CFHANDLEs generic event start pos
      $firstevchkctr++;
    }
    #RRULE etc will be created on the base of UID change as in some cases, RDATEs
    #are not part of last VEVENT. RDATEs may appear in any VEVENT also. So UID
    #will be used as criteria to check to process group VEVENTS e.g. VEVENTS with
    #same UID.
    elsif ($_=~/^UID:/)               #store UID
    {
      &log_message("$_");
      $rec->{'UID'} = $_;

      #set VEVENT begining point to truncate correclty,
      #even if VEVENTS are not in correct sequence.
      if($prvuid eq "")
      {
        $prvrecevpos=$begreceventpos;
      }
      if (($prvuid ne "")&&($prvuid ne $_))
      {
        $uidchangectr++;
        $IsFirstRecId=0;#reset
        #shift back to previous VEVENT start point as current one is with next UID
        $del_pos=$prvrecevpos;

        if(($IsfrstevStandalone)&&($uidchangectr>2))
        {
          $IsfrstevStandalone=0;
        }
        #if first event is standalone, it is getting wiped off.
        #set correct delpos
        if($firstevchkctr eq 2)
        {
          $IsfrstevStandalone=1;
          $frstevdelpos=$gen_evenstpos;
        }

        if((!$g_isdelrdate)&&($g_isrdate))
        {
          $Iscreaterrule=1;
          #UID for which processing should be done.
          $uidtosrch=$prvuid;
          $g_isrdate=0;
        }
        #if RDATEs should be deleted and current VEVENT has RDATEs
        elsif (($g_isdelrdate)&&($g_isrdate))
        {
          #delete previously added lines due to RRULE+RDATE events.
          #Delete position changes due to no RRULE creation.
          my $dpos= $gen_evenstpos;
          seek OTHANDLE, $dpos, 0;
          truncate OTHANDLE, $dpos or print "UID section:Couldn't truncate: $!\n";
          $begreceventpos= tell OTHANDLE;
        }
      }
      $g_isdelrdate=0;
      $prvuid=$_;
      #if rule was created at previous roll, reset IsFirstRecId
      #else a single event between 2 recurring events gets wiped out.
      if ($wasrulecreated)
      {
        $IsFirstRecId=0;#reset
        $wasrulecreated=0;
      }
    }
    elsif ($_=~/^DTSTART[:;]/)           #store DTSTART
    {
      $rec->{'DTSTART'} = $_;
    }
    elsif ($_=~/^DTEND[:;]/)             #store DTEND
    {
      $rec->{'DTEND'} = $_;
    }
    elsif ($_=~/^LOCATION:/)              #store LOCATION
    {
      my $loc=$_;
      $loc =~ s/^LOCATION://;
      $rec->{'LOCATION'} =$loc;
    }
    elsif ($_=~/^SUMMARY:/)              #store LOCATION
    {
      my $summary=$_;
      $summary =~ s/^SUMMARY://;
      $rec->{'SUMMARY'} =$summary;
    }
    elsif ($_=~/^DESCRIPTION:/)          #store DESCRIPTION
    {
      my $desc=$_;
      $desc =~ s/^DESCRIPTION://;
      $rec->{'DESCRIPTION'} =$desc;
    }
    elsif ($_=~/^RECURRENCE-ID[:;]/)  #store RECURRENCE-ID
    {
      $rec->{'RECURRENCE-ID'}=$_;
      $rec->{'MASTER_VEVENT'}=0;
    }
    elsif ($_=~/^RRULE/)              #check if RRULE is present
    {
      $rec->{'ISRRULE'}=1;
    }
    elsif ($_=~/^RDATE/)
    {
      $rec->{'ISRDATE'}=1;
      $g_isrdate=1;
      push @{$hrdate{$_}},$_;
      #Case 1.#if RDATEs should be deleted
      if ($deleteRDATE)
      {
        if ($rec->{'ISRRULE'})
        {
          $fdelete =1;
          $g_isdelrdate=1;
        }
      }
    }
    elsif ($_ =~/^ATTENDEE/)
    {
      #check for empty "mailto" and 'mailto' property existence
      #if it is empty or doesnt exists, remove corresponding ATTENDEE
      my $keepmove=1;
      my $tline=$_;
      my $cmptline=$tline;
      my $nomailto=0;
      my $npos;
      my $curpos=tell CFHANDLE;
      while ($keepmove)
      {
        if (($cmptline =~/mailto:/)||($nomailto))
        {
          $keepmove=0;
          if(($cmptline =~/mailto:$/)||($nomailto))
          {
            my $nline;
            if (!$nomailto)
            {
              $npos= tell CFHANDLE;
              $nline = readline(*CFHANDLE);
            }
            else
            {
              $nline = $tline;
            }
            if ($nline=~/ATTENDEE|END/)
            {
              if ($nomailto)
              {
                &log_message("$cmptline");
                &log_message("WARNING: No 'mailto:' found. May cause import error.\n");
              }
              else
              {
                &log_message("$tline");
                &log_message("WARNING: EMPTY 'mailto:' found. May cause import error.\n");
              }
              &log_message("Removing it from output file.");
              $fdelete=1;
              seek CFHANDLE,$npos,0;
              #remove from recdata array else will destroy recurring event.
              my $item = pop(@recdata);
              &log_message("removed from rec array:$item");
            }
            else
            {
              seek CFHANDLE,$curpos,0;
            }
          }
          else
          {
            #check if some part of mailto: is left,
            #if yes, add it before exiting.
            #It will be used to create attendee list (exception creation, if attendees changed!)
            my $iline;
            $npos= tell CFHANDLE;
            $iline = readline(*CFHANDLE);
            if ($iline =~/ATTENDEE|END/)
            {
              #nothing to do here...
            }
            else
            {
              #trim to avoid any start/end spaces
              $iline = trim($iline);
              $cmptline = $cmptline.$iline;
            }
            #create attendee list
            push(@attendeearr,$cmptline);
            #set to startpos
            seek CFHANDLE,$curpos,0;
          }
        }
        else
        {
          $npos= tell CFHANDLE;
          $tline = readline(*CFHANDLE);
          #trim to avoid any start/end spaces
          $tline = trim($tline);
          #form complete ATTENDEE line as 'mailto' may be divided into more than one line
          $cmptline = $cmptline.$tline;
          #globally replace all line-feeds with nothing
          $cmptline =~ s/\n//g;
          #globally replace all carriage-returns with nothing
          $cmptline =~ s/\r//g;
          #if next ATTENDEE or END:VEVENT found, it means no 'mailto' is found!!!.
          if ($tline =~/ATTENDEE|END/)
          {
            $nomailto=1;
          }
        }
      }#end while keepmove
    }
    elsif ($_=~/^END:VEVENT/)         #end of VEVENT
    {
      foreach my $rdate ( sort keys %hrdate)
      {
        &log_message("$rdate \n");
      }
      $rec->{'RDATE'}= {%hrdate};
      $rec->{'RECDATA'} = [@recdata];
      $rec->{'ATTENDEES'} = [@attendeearr];
      push @{$hlist{$rec->{'UID'}}}, $rec;
      %hrdate=();
      $enveventpos=tell CFHANDLE;#remember last vevent end pos
      &log_message("--End VEVENT component.");
    }
    #uniical exports ics file with VCALANDER component for each UID group
    elsif($_=~/^END:VCALENDAR/)
    {
      if (($uidtosrch ne $prvuid)&&(!$g_isdelrdate)&&($g_isrdate))
      {
        $Iscreaterrule=1;
        $uidtosrch=$prvuid;
        $del_pos=$prvrecevpos;
      }
      else
      {
        $prvuid="";
      }
      $g_isdelrdate=0;
      $g_isrdate=0;
      $IsFirstRecId=0;
    }
#Case: 1 *******************************************************>>>>>>>>>>>
    #shall we delete the RDATEs from VEVENT with RRULE and RDATEs?
    #if $fdelete is false, dont include the line
    my $read_pos = tell CFHANDLE;
    seek OTHANDLE, $write_pos, 0;
    if (!$fdelete)
    {
      if (/^DTSTART/)
      {
        my $tzdtst= $_;
        $tzdtst=~ s/DTSTART/DTSTART$TZTag/;
        print_outfile("$tzdtst");
      }
      elsif (/^DTEND/)
      {
        my $tzdten= $_;
        $tzdten=~ s/DTEND/DTEND$TZTag/;
        print_outfile("$tzdten");
      }
      elsif (/^RECURRENCE-ID/)
      {
        my $tzrecid= $_;
        $tzrecid=~ s/RECURRENCE-ID/RECURRENCE-ID$TZTag/;
        print_outfile("$tzrecid");
      }
      #Add METHOD:PUBLISH to avoid NPE during import
      elsif (/^BEGIN:VCALENDAR/)
      {
        print_outfile ($_);
        &Add_METHOD_PUBLISH;
        $write_pos = tell OTHANDLE;
      }
      else
      {
        #write to output file
        print_outfile ($_) ;
      }
    }
    else
    {
      &log_message("Deleting $_");
    }
#End Case:1 *****************************************************<<<<<<<<<

#Case: 2 & Case: 3***********************************************>>>>>>>>>>
    #shall we create new RRULE for RDATEs only VEVENT?
    if ($Iscreaterrule)
    {
      &log_message("Creating event with RRULE....");
      #deletion start position
      my $delstpos= $del_pos;
      if($IsfrstevStandalone)
      {
        $delstpos = $frstevdelpos;
        $IsfrstevStandalone=0;
      }
      #truncate file till delstpos
      seek OTHANDLE, $delstpos, 0;
      truncate OTHANDLE, $delstpos or print "Couldn't truncate: $!\n";
      #reset to last event component
      seek CFHANDLE,$enveventpos,0;
      #get array of recurring events with same UID
      my @newrecarr= @{$hlist{$uidtosrch}};
      my @masterrecdata; my $delta_days; my $rdarray;
      my $masterrec;
      my $RPrulecreated=0; my $checkforltdex=0;
      my $sEvDate=0; my $eEvDate=0;
      my $orig_mstrsdt=0; my $orig_mstredt=0;
      my %srtd_newrecarr=();
      my %ltd_exlist=(); my $lmt_listrec={};  my %weekenddate_list=();
      my $islocchanged=0; my $issmrychanged=0; my $isattndchanged=0;
      my $isrdtimeok=1;my $isdescchanged=0; my $isweekdayok=1;
      my $isrdtdeleted=0;
      my %week_day_arr_list=();
      #iterate through all occurences
      my %heventdates=();
      foreach my $newrec (@newrecarr)
      {
        #store all events DTSTART and DTEND so that first group date can be extracted
        #to create master VEVENT as master can appear on any group date in some cases.
        push @{$heventdates{$newrec->{'DTSTART'}}},$newrec->{'DTEND'};
        #find master event
        if ($newrec->{'MASTER_VEVENT'})
        {
          $masterrec= $newrec;
        }
        #create sorted hash for recurrences else exceptions are created in random way and cannot be shown in UI
        push @{$srtd_newrecarr{$newrec->{'DTSTART'}}},$newrec;
      }#end foreach my $newrec
      
      &print_srtdnewrecarr(%srtd_newrecarr);
      
      #get first event dates
      my $key;
      foreach $key (sort keys %heventdates)
      {
        $sEvDate = $key;
        $eEvDate= $heventdates{$key}[0];
        last;
      }
        
      #check for nonStandardDTSTART
      if ($nonStandardDTSTART)
      {
        #check if masterrec DTSTART is not equal to oldest RDATE.
        #(29805)if so make oldest RDATE event as master and add master's DTSTART to rdate array.
        if ($masterrec->{'DTSTART'} ne $sEvDate)
        {
          &log_message("WARNING:Masterrec DTSTART is not same as oldest RDATE.icalmig will adopt nonStandardDTSTART.");
          my $mstrdtstart=$masterrec->{'DTSTART'};
          my $mstrdtend=$masterrec->{'DTEND'};

          #srdt_array modifications----->
          #put old masterrec date in least DTSTART containing object
          my $firstrec=$srtd_newrecarr{$sEvDate}[0];
          my $frstrectstartdt= $firstrec->{'DTSTART'};
          my $frstrecenddt=  $firstrec->{'DTEND'};
          #delete it
          delete ($srtd_newrecarr{$firstrec->{'DTSTART'}});
          $firstrec->{'DTSTART'}=$mstrdtstart;
          $firstrec->{'DTEND'}=$mstrdtend;
          
          #put least DTSTART/DTEND in masterrec
          my $newmstrrec= $srtd_newrecarr{$mstrdtstart}[0];
          #delete it
          delete($srtd_newrecarr{$newmstrrec->{'DTSTART'}});
          $newmstrrec->{'DTSTART'}=$frstrectstartdt;
          $newmstrrec->{'DTEND'}=$frstrecenddt;
          
          #push modified instances
          push @{$srtd_newrecarr{$firstrec->{'DTSTART'}}},$firstrec;
          push @{$srtd_newrecarr{$newmstrrec->{'DTSTART'}}},$newmstrrec;
          #srdt_modifications end--------<
          
          #rdarray modifications------->
          my $rdarr;
          $rdarr = ($masterrec->{'RDATE'});
          #delete RDATE
          $frstrectstartdt=~ s/DTSTART/RDATE/;
          delete ($rdarr->{$frstrectstartdt});
          #Add old masterrec date
          $mstrdtstart=~ s/DTSTART/RDATE/;
          push @{$rdarr->{$mstrdtstart}},$mstrdtstart;
          &print_srtdnewrecarr(%srtd_newrecarr);
        }
      }
      #will remove any RDATE occurences which are before master even DTSTART
      elsif($StandardDTSTART)
      {
        #(29743)for making it RFC compliant, make masterrec as start event and delete older rdates from rdate array.
        if ($masterrec->{'DTSTART'} ne $sEvDate)
        {
          my $mstrdtstart=$masterrec->{'DTSTART'};
          $mstrdtstart=~ s/DTSTART/RDATE/;
          my $rdarr;
          $rdarr = ($masterrec->{'RDATE'});
          for my $key ( sort keys %$rdarr)
          {
            if($key lt $mstrdtstart)
            {
              delete ($rdarr->{$key});
              my $tdtdst= $key;
              $tdtdst=~ s/RDATE/DTSTART/;
              delete($srtd_newrecarr{$tdtdst});
              $isrdtdeleted=1;
            }
          }#end for
        }#end if
      }#end else


      #Create master event
      if ($masterrec->{'MASTER_VEVENT'})
      {
        &log_message("Creating master event. UID:$masterrec->{'UID'}");
        #create master VEVENT with all data as it is except RADTEs and
        #create new RRULE section
        @masterrecdata= @{$masterrec->{'RECDATA'}};
        my $isrruledone=0;
        my $IsfirstRdate=1; my $firstrdate=0; my $lastrdate=0;
        my $val;
        #write MasterEvent properties and modify needed values
        for(my $i=0; $i<$#masterrecdata+1; $i++)
        {
          my $str=$masterrecdata[$i];
          #if RDATE; calculate RDATE range and create RRULE with
          #exceptions for same dates
          if ($str =~/^RDATE/)
          {
            &log_message("Removed: $str");
            if (!$isrruledone)
            {
              #if RRULE should be created on recurrence pattern
              if ($createPatternRRULE)
              {
                my $dlctr=0;my $wkctr=0; my $bwkctr=0;
                $rdarray= ($masterrec->{'RDATE'});
                #Add master date too in rdarray for pattern calculation.
                #It WILL be removed after pattern calculation
                my $tmdts= $masterrec->{'DTSTART'};
                $tmdts=~ s/DTSTART/RDATE/;
                push @{$rdarray->{$tmdts}},$tmdts;

                #get master weekday;Will be used to check for RDATE weekdays.
                #if master weekday is not same as RDATE weekdays, create exceptions.
                #As it is possible that recurrence has been changed to another weekday
                #later.
                my $midx= rindex($masterrec->{'DTSTART'},':');
                my $mdt= substr($masterrec->{'DTSTART'},$midx+1);
                my $masterweekday=get_weekday($mdt);
                
                #get time difference of rdate appointments, if time is different
                #create exceptions else only RRULE will create recurrence only
                #on base of master event
                my $msttime=$mdt;
                
                #store masterrect location to check with occurence's location,
                #if changed, exception should be cerated
                my $mlocation= $masterrec->{'LOCATION'};
                
                #store masterrec summary to check with occurence's summary,
                #if changed, exception should be cerated
                my $msummary= $masterrec->{'SUMMARY'};
                
                #store attendee to check with occurrence's attendee list,
                #if changed, exception should be created
                my @mattendeearr= @{$masterrec->{'ATTENDEES'}};
                
                #store description to check with occurrence's description,
                #if changed, exception should be created
                my $mdescription= $masterrec->{'DESCRIPTION'};
                
                my $k1;my $k2;my $v1; my $v2;
                my $rweekday;
                my $ioccurrec; my $ilocation;my $isummary;my @iattenarr;my $idescription;
                my $floop=1;
                my $sdt;my $ndt;
                my $isweekendpresent=0; my $wkday; my $weekendcount=0;
                my $prvwkday=0;my $jstcrosswend=0;
                my $weekenddaypassed=0;
                my @weekday_arr;
                %week_day_arr_list=();
                my $startwkday=-1;my $endwkday=-1;
                for my $k1 ( sort keys %$rdarray )
                {
                  #for weekend present check and passed weekend calculations
                  my $twdidx= rindex($k1,':');
                  my $tk1= substr($k1,$twdidx+1);
                  $wkday= get_weekday($tk1);
                  #store start weekday for weekly pattern calculation
                  if ($startwkday eq -1)
                  {
                    $startwkday= $wkday;
                  }
                  #check if weekend present
                  if ($wkday>5)
                  {
                    #yes it is there!
                    $isweekendpresent=1;
                    my $tdt=$k1;
                    $tdt=~ s/RDATE/DTSTART/;
                    $weekenddate_list{$tdt}=$wkday;
                    
                    #set it to 1 if just saturday has passed. set to 0 when sunday passed
                    #as weekendcount will increment so no need to keep track of just saturday
                    $weekenddaypassed=1;
                  }
                  if ($prvwkday>$wkday)
                  {
                    $weekendcount++;
                    $jstcrosswend=1;
                    #reset it after weekend gone
                    $weekenddaypassed=0;
                  }
                  $prvwkday=$wkday;
                  
                  #Store weekdays date in hash array
                  if ($wkday eq 1)
                  {
                    push @{$week_day_arr_list{"MO"}}, $k1;
                  }
                  elsif ($wkday eq 2)
                  {
                    push @{$week_day_arr_list{"TU"}}, $k1;
                  }
                  elsif ($wkday eq 3)
                  {
                    push @{$week_day_arr_list{"WE"}}, $k1;
                  }
                  elsif ($wkday eq 4)
                  {
                    push @{$week_day_arr_list{"TH"}}, $k1;
                  }
                  elsif ($wkday eq 5)
                  {
                    push @{$week_day_arr_list{"FR"}}, $k1;
                  }
                  elsif ($wkday eq 6)
                  {
                    push @{$week_day_arr_list{"SA"}}, $k1;
                  }
                  elsif ($wkday eq 7)
                  {
                    push @{$week_day_arr_list{"SU"}}, $k1;
                  }
                  if ($floop)  #first loop
                  {
                    $k2=$k1;
                    $firstrdate=$k1;
                    $lastrdate=$k1;
                    $sdt= $k2;
                    $ndt=$k1;
                    $floop=0;
                  }
                  else
                  {
                    $sdt= $k2;
                    $ndt=$k1;
                    my $rsdt= $sdt;
                    $rsdt=~ s/RDATE/DTSTART/;
                    $ioccurrec=$srtd_newrecarr{$rsdt}[0];
                    $ilocation= $ioccurrec->{'LOCATION'};
                    $isummary = $ioccurrec->{'SUMMARY'};
                    @iattenarr = @{$ioccurrec->{'ATTENDEES'}};
                    $idescription= $ioccurrec->{'DESCRIPTION'};
                    my $tidx= rindex($sdt,':');
                    $sdt= substr($sdt,$tidx+1);
                    $ndt = substr($ndt,$tidx+1);
                    #check for rdate weekdays
                    $rweekday= get_weekday($sdt);
                    #if master weekday is not same as RDATE weekday
                    if ($masterweekday != $rweekday)
                    {
                      $isweekdayok=0;
                      $ltd_exlist{$rsdt}=1;
                    }
                    
                    #check for if master date time is equal to rdate time component
                    my $rsttime= $sdt;
                    if (!istime_equal($msttime,$sdt))
                    {
                      $isrdtimeok = 0;
                      $ltd_exlist{$rsdt}=0;
                      &log_message("occurrence time changed->master-time:$msttime recur-time:$rsttime");
                    }
                    #if location changed, create exceptions
                    if ($mlocation ne $ilocation)
                    {
                      $islocchanged=1;
                      $ltd_exlist{$rsdt}=0;
                      &log_message("occurrence location changed->master-location:$mlocation recur-location:$ilocation");
                    }
                    #if summary changed, create exceptions
                    if ($msummary ne $isummary)
                    {
                      $issmrychanged=1;
                      $ltd_exlist{$rsdt}=0;
                      &log_message("occurrence summary changed->master-summary:$msummary recur-summary:$isummary");
                    }
                    #if attendees changed, create exception
                    if ($#iattenarr eq $#mattendeearr)
                    {
                      for(my $j=0; $j<$#iattenarr+1; $j++)
                      {
                        if ($iattenarr[$j] ne $mattendeearr[$j])
                        {
                          $isattndchanged=1;
                          $ltd_exlist{$rsdt}=0;
                          &log_message("occurrence attendees changed \nmaster-attendees:@mattendeearr \nrecur-attendee:@iattenarr");
                        }
                      }
                    }
                    else
                    {
                      $isattndchanged=1;
                      $ltd_exlist{$rsdt}=0;
                      &log_message("occurrence attendees changed \nmaster-attendees:@mattendeearr \nrecur-attendee:@iattenarr");
                    }
                    #if description changed, create exceptions
                    if ($mdescription ne $idescription)
                    {
                      $isdescchanged=1;
                      $ltd_exlist{$rsdt}=0;
                      &log_message("occurrence description changed->master-summary:$mdescription recur-summary:$idescription");
                    }
                    
                    #delta days
                    $delta_days=get_date_diff($sdt, $ndt);
                    if (($delta_days==$DAILY)||(($jstcrosswend)&&($delta_days<=3)))
                    {
                      $dlctr++;
                      &log_message("Delta: DAILY");
                    }
                    elsif($delta_days==$WEEKLY)
                    {
                      $wkctr++;
                      &log_message("Delta: WEEKLY");
                    }
                    elsif($delta_days==$BIWEEKLY)
                    {
                      $bwkctr++;
                      &log_message("Delta: BIWEEKLY");
                    }
                    $k2=$k1;
                    $lastrdate=$k1;
                    print "$delta_days";
                    $jstcrosswend=0;
                  }
                } #end for my $k1...
                
                #check for last occurrence
                #***************************
                my $rndt= $lastrdate;
                $rndt=~ s/RDATE/DTSTART/;
                $ioccurrec=$srtd_newrecarr{$rndt}[0];
                my $tidx= rindex($ndt,':');
                $ndt = substr($ndt,$tidx+1);
                $rweekday= get_weekday($ndt);
                if ($endwkday eq -1)
                {
                  $endwkday= $rweekday;
                }
                #if master weekday is not same as ndt weekday
                if ($masterweekday != $rweekday)
                {
                  $isweekdayok=0;
                  $ltd_exlist{$rndt}=1;
                }
                #check for if master date time is equal to rdate time component
                if (!istime_equal($msttime,$ndt))
                {
                  $isrdtimeok = 0;
                  $ltd_exlist{$rndt}=0;
                  log_message("occurrence time changed->master-time:$msttime recur-time:$ndt");
                }
                #Get summary and location information
                $ilocation= $ioccurrec->{'LOCATION'};
                $isummary = $ioccurrec->{'SUMMARY'};
                @iattenarr = @{$ioccurrec->{'ATTENDEES'}};
                $idescription= $ioccurrec->{'DESCRIPTION'};
                #if location changed, create exceptions
                if ($mlocation ne $ilocation)
                {
                  $islocchanged=1;
                  $ltd_exlist{$rndt}=0;
                  &log_message("occurrence location changed->master-location:$mlocation recur-location:$ilocation");
                }
                #if summary changed, create exceptions
                if ($msummary ne $isummary)
                {
                  $issmrychanged=1;
                  $ltd_exlist{$rndt}=0;
                  &log_message("occurrence summary changed->master-summary:$msummary recur-summary:$isummary");
                }
                #if attendees changed, create exception
                if ($#iattenarr eq $#mattendeearr)
                {
                  for(my $j=0; $j<$#iattenarr+1; $j++)
                  {
                    if ($iattenarr[$j] ne $mattendeearr[$j])
                    {
                      $isattndchanged=1;
                      $ltd_exlist{$rndt}=0;
                      &log_message("occurrence attendees changed \nmaster-attendees:@mattendeearr \n recur-attendee:@iattenarr");
                    }
                  }
                }
                else
                {
                  $isattndchanged=1;
                  $ltd_exlist{$rndt}=0;
                  &log_message("occurrence attendees changed \nmaster-attendees:@mattendeearr \n recur-attendee:@iattenarr");
                }
                #if description changed, create exceptions
                if ($mdescription ne $idescription)
                {
                  $isdescchanged=1;
                  $ltd_exlist{$rndt}=0;
                  &log_message("occurrence description changed->master-summary:$mdescription recur-summary:$idescription");
                }
                #***************************
                #delete master dtstart from rdarray which was added for pattern
                #calculation before
                delete($rdarray->{$tmdts});
                
                my $rdpattern=0; my $freq; my $interval; my $rdcnt;
                $rdcnt= keys (%$rdarray);#-1;
                if (!$rdcnt)
                {
                  $rdcnt++;
                }

                #check for weekly pattern
                print_wdarrlist(\%week_day_arr_list);
                my @wkltd_exlist=();
                my $wkrrule=&get_weekly_rrule(\%week_day_arr_list,$weekendcount, $startwkday,$endwkday,\@wkltd_exlist);
                if ($wkrrule ne -1)
                {
                  print_outfile("$wkrrule");
                  &log_message("New RRULE: $wkrrule");
                  $RPrulecreated=1;
                  &log_message("WEEKLY RRULE CREATED.");
                  %ltd_exlist=();
                  for(my $wectr=0;$wectr<$#wkltd_exlist+1;$wectr++)
                  {
                    my $twkdt=@wkltd_exlist[$wectr];
                    $twkdt=~ s/RDATE/DTSTART/;
                    $ltd_exlist{$twkdt}=0;
                  }
                  $checkforltdex=1;
                  $isdescchanged=1;#To push into limited exception creation
                }

                if (!$RPrulecreated)
                {
	                #check for pattern
	                my $pmatch= ($dlctr/$rdcnt)*100; #DAILY
	                &log_message("DAILY Match Percentage: $pmatch");
	                if ($pmatch<$MATCHPC)
	                {
	                  $pmatch= ($wkctr/$rdcnt)*100;  #WEEKLY
	                  &log_message("WEEKLY Match Percentage: $pmatch");
	                  if($pmatch<$MATCHPC)
	                  {
	                    $pmatch= ($bwkctr/$rdcnt)*100; #BIWEEKLY
	                    &log_message("BIWEEKLY Match Percentage: $pmatch");
	                    if($pmatch<$MATCHPC)
	                    {
	                    }
	                    else
	                    {
	                      $rdpattern=$BIWEEKLY;
	                      $freq="WEEKLY";
	                      $interval=2;
	                    }
	                  }
	                  else
	                  {
	                    $rdpattern=$WEEKLY;
	                    $freq="WEEKLY";
	                    $interval=1;
	                  }
	                }
	                else
	                {
	                  $rdpattern=$DAILY;
	                  $freq="DAILY";
	                  $interval=1;
	                  #reset isweekok as in case of DAILY frequency, weekdays will
	                  #be always different.
	                  $isweekdayok=1;
	                }
	                &log_message("Total RDATEs: $rdcnt DailyCtr: $dlctr WeeklyCtr: $wkctr");
	
	                #### Exception/RRULE creation criteria ####
	                #1. if recurrence pattern found, No need to create exceptions
	                #2. if weekdays has changed due to meeting has moved to another day,
	                #   create complete series exception.
	                if (($rdpattern)&& ($isweekdayok))
	                    #&& ($isrdtimeok)
	                    #&& (!$islocchanged) &&(!$issmrychanged) &&(!$isattndchanged)
	                    #&& (!$isdescchanged))
	                {
	                  if ($freq eq "DAILY")
	                  {
	                    #create RRULE for exceptions
	                    my $ridx= rindex($firstrdate,':');
	                    if($ridx<0)
	                    {
	                      &log_message("No expected(:) delimiter found.Qutiing!!!") ;
	                      die "No expected(:) delimeter found. Quitting!!!";
	                    }
	                    my $fdt= substr($firstrdate,$ridx+1);
	                    my $ldt = substr($lastrdate,$ridx+1);
	                    #total weekend days present
	                    my $wkenddayspresent=keys(%weekenddate_list);
	                    #total weekend days crossed
	                    my $wkenddaycrossed= ($weekendcount*2);
	                    #delta days
	                    #if weekdays present, take complete day difference
	                    if($wkenddaycrossed eq $wkenddayspresent)#($isweekendpresent)
	                    {
	                      $delta_days=get_date_diff($fdt, $ldt)+1;
	                    }
	                    else#else deduct weekends and add any weekend exception
	                    {
	                      #no addition of exception count in delta_days
	                      $delta_days=get_date_diff($fdt, $ldt)+1;
	                      #deduct weekend count*2 and $weekenddaypassed, if just saturday has passed
	                      $delta_days = $delta_days - ($weekendcount*2)-$weekenddaypassed;
	                      #add weekend days in limited exception list for exception creation
	                      if($wkenddayspresent>0)
	                      {
	                        for my $wek1 ( sort keys %weekenddate_list )
	                        {
	                          $ltd_exlist{$wek1}=0;
	                        }
	                      }
	                    }
	                  }
	                  else
	                  {
	                    $delta_days=$rdcnt+1;
	                  }
	                  my $bywkday=";BYDAY=MO,TU,WE,TH,FR";
	                  my $newrrule= "RRULE:FREQ=$freq;COUNT=$delta_days;INTERVAL=$interval";
                    my $teststr="";
	                  if($freq eq "DAILY")#&&(!$isweekendpresent))
	                  {
                      $bywkday=&get_byday(\%week_day_arr_list);
	                    #set it to weekly instead of DAILY to avoid server side bug#30094
	                    $newrrule= "RRULE:FREQ=WEEKLY;COUNT=$delta_days;INTERVAL=$interval".$bywkday;
                      $teststr="DAILY";
	                  }
                    elsif($freq eq "WEEKLY")
	                  {
                      $bywkday=&get_byday(\%week_day_arr_list);
                      $newrrule= "RRULE:FREQ=WEEKLY;COUNT=$delta_days;INTERVAL=$interval".$bywkday;
                    }
	                  print_outfile("$newrrule");
	                  &log_message($teststr." New RRULE: $newrrule.");
	                  $RPrulecreated=1;
	                  $checkforltdex=1;
	                }
		            }
              }#end_if($createPatternRRULE)

              #if recurrence pattern based RRULE could NOT be created
              #Go for RRULE for exceptions
              if(!$RPrulecreated)
              {
                if (!$isweekdayok)
                {
                  &log_message("Weekday changed. Going for Yearly recurrnce");
                }
                #create RRULE for exceptions
                my $ridx= rindex($firstrdate,':');
                if($ridx<0)
                {
                  &log_message("No expected(:) delimiter found.Qutiing!!!") ;
                  die "No expected(:) delimeter found. Quitting!!!";
                }
                my $fdt= substr($firstrdate,$ridx+1);
                my $ldt = substr($lastrdate,$ridx+1);
                #delta days
                $delta_days=get_date_diff($fdt, $ldt)+1;
                my $reccnt=keys(%$rdarray)+1;
                my $newrrule= "RRULE:FREQ=YEARLY;COUNT=$reccnt;INTERVAL=1";
                print_outfile("$newrrule");
                &log_message("New RRULE: $newrrule.");
                $checkforltdex=0;
              }
            }#end if (!$isrruledone)
            $isrruledone=1;
          }
          elsif ($str =~/^DTSTART/)
          {
            my $tzdtst;
            if($isrdtdeleted)
            {
              $tzdtst=$str;
            }
            else
            {
              $tzdtst= $sEvDate;
            }
            $orig_mstrsdt=$str;
            $tzdtst=~ s/DTSTART/DTSTART$TZTag/;
            print_outfile("$tzdtst");
            &log_message("New DTSTART: $tzdtst");
          }
          elsif ($str =~/^DTEND/)
          {
            my $tzdten;
            if($isrdtdeleted)
            {
              $tzdten=$str;
            }
            else
            {
              $tzdten= $eEvDate;#$str;
            }
            $orig_mstredt=$str;
            $tzdten=~ s/DTEND/DTEND$TZTag/;
            print_outfile("$tzdten");
            &log_message("$tzdten");
          }
          else  #keep writing in Outfile
          {
            print_outfile("$str");
          }
        }#end writing masterrecdata--creating master event with RRULE
        &log_message("Master event created.");
      }#end ($$masterrec->{'MASTER_VEVENT'})

      #if pattern has found and any of following is changed. Create exception
      #only for changed occurences else exceptions will be created for complete series.
      #1. if time has changed for RDATE occurences.
      #2. if LOCATION changed for any occurrence.
      #3. if SUMMARY changed for any occurences.
      #4. if ATTENDEE list changed for any occurrence.
      #5. if DESCRIPTION changed for any occurrence.
      #6. WEEKDAY MUST BE OK. ELSE CREATE SERIES EXCEPTION
      if (($checkforltdex)&& ((!$isrdtimeok)
          || ($islocchanged) ||($issmrychanged)
          || ($isattndchanged) || ($isdescchanged)
          || ($isweekdayok)))
      {
        &log_message("Checking limited exception occurrences");
        my $recidfmtstr="";
        my $recctr=1;
        my $mstrdtstart = $masterrec->{'DTSTART'};
        my $ndtstart=$mstrdtstart;
        my $idx2= index($mstrdtstart,';');
        my $ridx= rindex($mstrdtstart,':');
        my $recidfmtstr="";
        if ($idx2>0)
        {
          $recidfmtstr=substr($mstrdtstart,$idx2,($ridx-$idx2)+1);
        }
        else
        {
          $recidfmtstr=":";
        }
        $mstrdtstart = substr($mstrdtstart,$ridx+1);
        my $ndtstart=$mstrdtstart;
        my $syear= substr($ndtstart,0,4);

        foreach my $srdtkey (sort keys %ltd_exlist)
        {
          my $wdc =$ltd_exlist{$srdtkey};
          my $ctoccurrence=1;
          #if only weekday changed and weekdays are OK then skip it.
          if (($wdc ==1)&&($isweekdayok))
          {
            $ctoccurrence=0;
          }
          if ($ctoccurrence)
          {
            my $occurrec=$srtd_newrecarr{$srdtkey}[0];
            #only for recurrences
            if (!$occurrec->{'MASTER_VEVENT'})
            {
              &log_message("Creating limited Recurrence:");
              my @occurrecdata= @{$occurrec->{'RECDATA'}};
              for(my $i=0; $i<=$#occurrecdata; $i++)
              {
                my $str=$occurrecdata[$i];

                if ($str =~/^DTSTART/)
                {
                  my $tzdtst= $str;
                  $tzdtst=~ s/DTSTART/DTSTART$TZTag/;
                  print_outfile("$tzdtst");
                  &log_message("New DTSATRT:$tzdtst");
                }
                elsif ($str =~/^DTEND/)
                {
                  my $tzdten= $str;
                  $tzdten=~ s/DTEND/DTEND$TZTag/;
                  print_outfile("$tzdten");
                  &log_message("New DTEND: $tzdten");
                }
                elsif($str =~/^RECURRENCE-ID/)
                {
                  my $rndtt; my $rntime;
                  if(!$isrdtimeok)
                  {
                    $rndtt=$occurrec->{'DTSTART'};
                    $rndtt=~ s/DTSTART$recidfmtstr//;
                    $rndtt=get_date($rndtt);
                    $rntime = get_time($ndtstart);
                    $rndtt= "RECURRENCE-ID$TZTag$recidfmtstr$rndtt"."T$rntime";
                  }
                  else
                  {
                    $rndtt= $str;
                    $rndtt=~ s/RECURRENCE-ID/RECURRENCE-ID$TZTag/;
                  }
                  print_outfile("$rndtt");
                }
                elsif($str =~/^CREATED/)
                {
                 #do nothing
                }
                elsif ($str =~/^UID/)
                {
                  #for log purpose only
                  &log_message("$str");
                  print_outfile("$str");
                }
                else
                {
                  print_outfile("$str");
                }
              }# end_for(my $i=0...)
              &log_message("Limited recurrence Created.");
            }#end_if (!$occurrec->{'MASTER_VEVENT'})
          }
        }#end_foreach my $srdtkey
        $begreceventpos= tell OTHANDLE;
        &log_message("Check for limited Recurrences finished.");
        $RPrulecreated=1;
      }

      #if RRULE for exceptions created, create recurrences
      if(!$RPrulecreated)
      {
        &log_message("Creating Recurrences...");
        my $recctr=1;
        #get last datetime portion
        $rdarray = ($masterrec->{'RDATE'});
        my $mstrdtstart = $masterrec->{'DTSTART'};
        my $idx2= index($mstrdtstart,';');
        my $ridx= rindex($mstrdtstart,':');
        my $recidfmtstr="";
        if ($idx2>0)
        {
          $recidfmtstr=substr($mstrdtstart,$idx2,($ridx-$idx2)+1);
        }
        else
        {
          $recidfmtstr=":";
        }
        $mstrdtstart = substr($mstrdtstart,$ridx+1);
        my $ndtstart=$mstrdtstart;
        my $syear= substr($ndtstart,0,4);

        foreach my $srdtkey (sort keys %srtd_newrecarr)
        {
          my $occurrec=$srtd_newrecarr{$srdtkey}[0];
          #only for recurrences
          if (!$occurrec->{'MASTER_VEVENT'})
          {
            &log_message("Creating Recurrence:");
            my @occurrecdata= @{$occurrec->{'RECDATA'}};
            for(my $i=0; $i<=$#occurrecdata; $i++)
            {
              my $str=$occurrecdata[$i];
            
              if ($str =~/^DTSTART/)
              {
                #create RECURRENCE-ID
                #it should be increment to masterevent's DTSTART
                #and continue for range need to cover
                #increment by year as Outlook cannot show exceptions, if
                #recurrecneID is less than the DTSTART
                $syear++;
                $ndtstart= $syear.substr($ndtstart,4);
                #$ndtstart= get_date_by_days($ndtstart,$dyinyr); #for yearly increment
                my $rndtstart= "RECURRENCE-ID$TZTag$recidfmtstr$ndtstart";
                print_outfile("$rndtstart");
                &log_message("New RECURRENCE-$rndtstart");
                $recctr++;
              
                #start date
                #if RDATEs are not in sequence than master date shifts to first
                #date(RDATE) so master original date should appear as RDATE.
                if ($sEvDate eq $str)
                {
                  $str=$orig_mstrsdt;
                }
                my $tzdtst= $str;
                $tzdtst=~ s/DTSTART/DTSTART$TZTag/;
                print_outfile("$tzdtst");
                &log_message("New DTSATRT:$tzdtst");
              }
              elsif ($str =~/^DTEND/)
              {
                if ($eEvDate eq $str)
                {
                  $str=$orig_mstredt;
                }
                my $tzdten= $str;
                $tzdten=~ s/DTEND/DTEND$TZTag/;
                print_outfile("$tzdten");
                &log_message("New DTEND: $tzdten");
              }
              elsif($str =~/^RECURRENCE-ID/)
              {
                &log_message("Old Recurrence-Id: $str");
                #do nothing as we create REC-ID with DTSTART
              }
              elsif($str =~/^CREATED/)
              {
                #do nothing
              }
              elsif ($str =~/^UID/)
              {
                #for log purpose only
                &log_message("$str");
                print_outfile("$str");
              }
              else
              {
                print_outfile("$str");
              }
            }
            &log_message("Recurrence Created.");
          }
        }
        $begreceventpos= tell OTHANDLE;
        &log_message("All Recurrences Created.");
      }

      $Iscreaterrule=0;
      #next write position
      $write_pos = tell OTHANDLE;
      $begreceventpos= tell OTHANDLE;
      $wasrulecreated=1;
    }
    else
    {
      $write_pos = tell OTHANDLE;
      seek CFHANDLE, $read_pos, 0;
      $fdelete=0;
    }
#END Case 2: ***************************************************<<<<<<<<<<<<

  } #end while<CFHANDLE>
  
  &log_message("processing finished");
  return %hlist;
}

sub print_wdarrlist
{
  my $hashlist= shift;
  foreach my $wdkey (keys %$hashlist)
  {
    my @wdarr =@{$hashlist->{$wdkey}};
    my $wkdctr=0;
    for (my $i=0;$i<$#wdarr+1;$i++)
    {
      &log_message("$wdkey: $wdarr[$i]");
    }
  }
}

sub get_byday
{
  my $week_day_arr_list=shift;
  my $bywkday=";BYDAY=";
  my @srtdarr=("","","","","","","");
  foreach my $pdkey (keys %$week_day_arr_list)
  {
    $srtdarr[get_str_weekday($pdkey)]=$pdkey;
  }
  my $oneadded=0;
  for (my $k=0;$k<$#srtdarr+1;$k++)
  {
    if($srtdarr[$k] ne "")
    {
      if ($oneadded)
      {
        $bywkday =  $bywkday.",".$srtdarr[$k];
      }
      else
      {
        $bywkday =  $bywkday.$srtdarr[$k];
        $oneadded=1;
      }
    }
  }
  return $bywkday;
}

sub get_weekly_rrule
{
  my $wkdaylist=shift;
  my $wkendcnt= shift;
  my $stwkday= shift;
  my $enwkday = shift;
  my $twkltd_exlist=shift;
  my $strwkday= &get_weekday_str($stwkday);
  my %weekday_pattern_list=();
  my $wdctr=0;
  my $patternfound=1;
  my @exceptionlist=();
  my $occur_ctr=0;
  my $patternclaculated=0;
  #Create pattern list
  foreach my $wdkey (keys %$wkdaylist)
  {
    my @wdarr =@{$wkdaylist->{$wdkey}};
    my $wkdctr=0;
    $patternclaculated=0;
    for (my $i=0;$i<$#wdarr+1;$i++)
    {
      print "$wdkey: $wdarr[$i]\n";
      $occur_ctr++;
      if ($i>0)
      {
        my $dt1= get_datepart_from_icsdt($wdarr[$i-1]);
        my $dt2= get_datepart_from_icsdt($wdarr[$i]);
        my $ddf=get_date_diff($dt1,$dt2);
        #create pattern list
        push @{$weekday_pattern_list{$wdkey}}, $ddf;
        my $wkday=get_weekday($dt1)+1;# +1 to adjsut for weekend calc
        my $wkdayctr=get_weekdaycount($wdarr[$i-1],$wdarr[$i],$wkday);
        print "weekday count: $wkdayctr \n";
        $patternclaculated=1;
      }#end if (i>0)
    }#end for loop
    if (!$patternclaculated)
    {
      return -1;
    }
    print "\n\n";
  }#end foreach
  
  #check for pattern consistency
  my %awkdaypattern_list=();
  foreach my $pkey (keys %weekday_pattern_list)
  {
    my $locpattern=0;
    my $isfailed=0;
    #pattern arr for each wkday
    my @parr =@{$weekday_pattern_list{$pkey}};
    for(my $i=0;$i<$#parr+1;$i++)
    {
      if ($i>0)
      {
        #if pattern is broken any time, it will not be considered
        if ($parr[$i] ne $parr[$i-1])
        {
          $locpattern=0;
          $isfailed=1;
        }#end if ($parr[$i] ne
        else
        {
          if((!$isfailed)&&(($parr[$i] % 7) eq 0))
          {
            $locpattern=1;
          }
        }
      }#end if (i>0)
    }#end for loop
    #how many weekdays have patterns
    if ($locpattern)
    {
      $awkdaypattern_list{$pkey}=$parr[0];
    }
    else
    {
      $awkdaypattern_list{$pkey}=-1;
    }
  }#end foreach loop
  
  #check how many pattern days found
  my $HasWkendException=0;
  foreach my $pdkey (keys %awkdaypattern_list)
  {
    my $tpattern =0;
    my $prvpattern =$tpattern;
    $tpattern = $awkdaypattern_list{$pdkey};
    #if weekend day has no pattern, we treat it as ok, it should go to exception list
    if ($tpattern eq -1)
    {
      #add weekend dates to exeption list
      if(IsWeekendDay($pdkey))
      {
        my @twdarr =@{$wkdaylist->{$pdkey}};
        for (my $j=0;$j<$#twdarr+1;$j++)
        {
          $twkltd_exlist->[$j]=$twdarr[$j];
          $HasWkendException=1;
          $occur_ctr--;
        }
        delete $awkdaypattern_list{$pdkey};
      }
      else
      {
        $patternfound =0;
      }
    }
    print "$tpattern \n";
  }

  my $wklyRrule="RRULE:FREQ=WEEKLY;COUNT=$occur_ctr";
  my $byday=";BYDAY=";
  my $interval=1;
  #build RRULE
  if ($patternfound)
  {
    my $pkctr=0;
    my $pkcount = keys %awkdaypattern_list;
    my @srtwkarr=("","","","","","","");
    foreach my $pdkey (keys %awkdaypattern_list)
    {
      $srtwkarr[get_str_weekday($pdkey)]=$pdkey;
      $interval = (($awkdaypattern_list{$pdkey})/7);
    }
    
    my $oneadded=0;
    for (my $k=0;$k<$#srtwkarr+1;$k++)
    {
      if($srtwkarr[$k] ne "")
      {
        if ($oneadded)
        {
          $byday =  $byday.",".$srtwkarr[$k];
        }
        else
        {
          $byday =  $byday.$srtwkarr[$k];
          $oneadded=1;
        }
      }
    }

    
    $wklyRrule= $wklyRrule.";INTERVAL=".$interval.$byday;
    if ($pkcount eq 0)
    {
      $patternfound=0;
    }
  }

  if ($patternfound)
  {
    return $wklyRrule;
  }
  else
  {
    return -1;
  }
  #my $newrrule= "RRULE:FREQ=$freq;COUNT=$delta_days;INTERVAL=$interval";
  #create expected day list on base of start and end date for date series.
  #it wll be used to compare the calcuated weekdays ctr. If same, it weekly recurrence
  #else.....
  #check for if weekends are included
  
}

#input startdate, enddate, weekday; whose count to be found
#date format : ICS date with DTSTART or RDATE
#Weekday representation
#1...Sunday
#2...Monday
#3...Tuesday
#4...Wednesday
#5...Thursday
#6...Friday
#7...Saturday
sub get_weekdaycount
{
  my $A1=shift;
  $A1=get_datepart_from_icsdt($A1);
  my $A2=shift;
  $A2=get_datepart_from_icsdt($A2);
  my $wkday=shift;
  
  #INT((WEEKDAY($A$1-2)-$A$1+$A2)/7)
  my $dt= get_date_by_days($A1,-$wkday);
  my $wkday= get_weekday($dt)+1;
  my $adjustedA1= get_date_by_days($A1,-$wkday);
  my $wkdayscount =  abs (int((get_date_diff($A2,$adjustedA1))/7));
  return $wkdayscount;
}

#check for only ST and SU string
sub IsWeekendDay
{
  my $wkday=shift;
  if (($wkday eq "SA")||($wkday eq "SU"))
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

sub get_str_weekday
{
  my $stwkday = shift;
  my $iwkday= "NA";
  if ($stwkday eq "MO")
  {
    $iwkday=1;
  }
  elsif ($stwkday eq "TU")
  {
    $iwkday=2;
  }
  elsif ($stwkday eq "WE")
  {
    $iwkday=3;
  }
  elsif ($stwkday eq "TH")
  {
    $iwkday=4;
  }
  elsif ($stwkday eq "FR")
  {
    $iwkday=5;
  }
  elsif ($stwkday eq "SA")
  {
    $iwkday=6;
  }
  elsif ($stwkday eq "SU")
  {
    $iwkday=7;
  }
  return $iwkday;

}


sub get_weekday_str
{
  my $stwkday = shift;
  my $strwkday= "NA";
  if ($stwkday eq 1)
  {
    $strwkday="MO";
  }
  elsif ($stwkday eq 2)
  {
    $strwkday="TU";
  }
  elsif ($stwkday eq 3)
  {
    $strwkday="WE";
  }
  elsif ($stwkday eq 4)
  {
    $strwkday="TH";
  }
  elsif ($stwkday eq 5)
  {
    $strwkday="FR";
  }
  elsif ($stwkday eq 6)
  {
    $strwkday="SA";
  }
  elsif ($stwkday eq 7)
  {
    $strwkday="SU";
  }
  return $strwkday;
}

#get date part from RADTE or DTSTART format string
#input param: ics date
sub get_datepart_from_icsdt
{
  my $icsdate= shift;
  my $tidx= rindex($icsdate,':');
  my $ndt = substr($icsdate,$tidx+1);
  return $ndt;
}


#get date by adding days into date
sub get_date_by_days
{
  my $tdate= @_[0];
  my $tdays = @_[1];
  
  my @darr = split(/T/, $tdate);
  my $tdt= $darr[0];
  my $yr= substr($tdt,0,4);
  my $mm= substr($tdt,4,2);
  my $dd= substr($tdt,6,2);

  (my $y2, my $m2, my $d2)= Add_Delta_Days($yr,$mm,$dd, $tdays);
  my $newdt  = sprintf("%d%02d%02d", $y2, $m2, $d2);
  if($darr[1])
  {
    $newdt = $newdt.'T'.$darr[1];
  }
  return $newdt;
}

#takes dates in yyyymmdd/yyyymmddThhmmss format and return number of days
sub get_date_diff
{
  #format: 20070302T153000Z, 20070406
  #check for Timezone format, presence of T
  my $fd=@_[0];
  my $ld=@_[1];
  my @darr = split(/T/, $fd);
  my $stdate= $darr[0];
  @darr =();
  @darr = split(/T/, $ld);
  my $endate= $darr[0];
  my $yr1= substr($stdate,0,4);
  my $mm1= substr($stdate,4,2);
  my $dd1= substr($stdate,6,2);

  my $yr2= substr($endate,0,4);
  my $mm2= substr($endate,4,2);
  my $dd2= substr($endate,6,2);
  my @date1 = ($yr1, $mm1, $dd1);
  my @date2  = ($yr2, $mm2, $dd2);
  
  my $diff = &Delta_Days(@date1, @date2);
  
  return $diff;
}

#Input format: 20070302T153000Z, 20070406
#returns Week Day
#'1' for Monday, '2' for Tuesday and so on until '7' for Sunday.
sub get_weekday
{
  my $dt=shift;
  my @darr = split(/T/, $dt);
  $dt= $darr[0];
  my $yr1= substr($dt,0,4);
  my $mm1= substr($dt,4,2);
  my $dd1= substr($dt,6,2);
  my $dow=Day_of_Week($yr1,$mm1,$dd1);
  my $tdow = Day_of_Week_to_Text($dow);
  #log_message("Weekday: $dow - $tdow");
  return $dow;
}

#Input format 20070302T153000Z, 20070406
#Compare 2 date-time components for eqality
sub istime_equal
{
  my $tm=shift;
  my @tarr = split(/T/, $tm);
  my $dt= $tarr[1];
  my $hr1= substr($dt,0,2);
  my $mn1= substr($dt,2,2);
  my $ss1= substr($dt,4,2);
  
  $tm=shift;
  @tarr= split(/T/, $tm);
  $dt= $tarr[1];
  my $hr2= substr($dt,0,2);
  my $mn2= substr($dt,2,2);
  my $ss2= substr($dt,4,2);
  if(($hr1==$hr2)&&($mn1==$mn2)&&($ss1==$ss2))
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

#Input format 20070302T153000Z, 20070406
#returns DATE part
sub get_date
{
  my $dt=shift;
  my @darr = split(/T/, $dt);
  $dt= $darr[0];
  return $dt;
}

#Input format 20070302T153000Z, 20070406
#returns TIME part
sub get_time
{
  my $tm=shift;
  my @darr = split(/T/, $tm);
  $tm= $darr[1];
  return $tm;
}


sub print_outfile
{
  my $str=@_[0];
  chomp($str);
  print OTHANDLE "$str\n";
}

sub print_invalidfile
{
  my $str=@_[0];
  chomp($str);
  print IVHANDLE "$str\n";

}
#test function
#input param: hash list
sub print_hlist
{
  my %tmphlist = @_;
  foreach my $uid ( sort keys %tmphlist)
  {
    &log_message("$uid");
    foreach my $rec ( @{$tmphlist{$uid}} )
    {
      if ($rec->{'MASTER_VEVENT'})
      {
        &log_message("MASTER VEVENT");
        my $rdarr= $rec->{$uid}{'RDATE'};
        for my $trdate (@$rdarr)
        {
          &log_message("RDATEs: $trdate");
        }
      }
      &log_message("    $rec->{'RECURRENCE-ID'}");
    }
  }
}

#test function
sub print_srtdnewrecarr
{
  my %tmphlist = @_;
  foreach my $srdate ( sort keys %tmphlist)
  {
    &log_message("$srdate");
  }
}

# trim function to remove whitespace from the start and end of the string
sub trim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;
}
# Left trim function to remove leading whitespace
sub ltrim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	return $string;
}
# Right trim function to remove trailing whitespace
sub rtrim($)
{
	my $string = shift;
	$string =~ s/\s+$//;
	return $string;
}

#TimeZone information header for EST5EDT
sub init_TZHeader
{
  @TZHeader =(
  "BEGIN:VTIMEZONE",
  "TZID:EST5EDT",
  "BEGIN:DAYLIGHT",
  "RRULE:FREQ=YEARLY;UNTIL=20750314T020000Z;BYMONTH=3;BYDAY=2SU",
  "TZNAME:Eastern Standard Time\, Eastern Daylight Time",
  "TZOFFSETTO:-0400",
  "TZOFFSETFROM:-0500",
  "DTSTART:20070308T020000",
  "END:DAYLIGHT",
  "BEGIN:STANDARD",
  "RRULE:FREQ=YEARLY;UNTIL=20751107T020000Z;BYMONTH=11;BYDAY=1SU",
  "TZNAME:Eastern Standard Time\, Eastern Daylight Time",
  "TZOFFSETTO:-0500",
  "TZOFFSETFROM:-0400",
  "DTSTART:20071101T020000",
  "END:STANDARD",
  "BEGIN:DAYLIGHT",
  "RRULE:FREQ=YEARLY;UNTIL=20060407T020000Z;BYMONTH=4;BYDAY=1SU",
  "TZNAME:Eastern Standard Time\, Eastern Daylight Time",
  "TZOFFSETTO:-0400",
  "TZOFFSETFROM:-0500",
  "DTSTART:19910401T020000",
  "END:DAYLIGHT",
  "BEGIN:STANDARD",
  "RRULE:FREQ=YEARLY;UNTIL=20061031T020000Z;BYMONTH=10;BYDAY=-1SU",
  "TZNAME:Eastern Standard Time\, Eastern Daylight Time",
  "TZOFFSETTO:-0500",
  "TZOFFSETFROM:-0400",
  "DTSTART:19911025T020000",
  "END:STANDARD",
  "END:VTIMEZONE"
  );
  $TZTag= ";TZID=EST5EDT";
}
sub Add_TZHeader
{
  my $i;
  for($i=0;$i <= $#TZHeader;$i++)
  {
    print_outfile("$TZHeader[$i]");
  }
}

sub Add_METHOD_PUBLISH
{
  print_outfile("METHOD:PUBLISH");
}
