/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Server
 * Copyright (C) 2010 Zimbra, Inc.
 *
 * The contents of this file are subject to the Zimbra Public License
 * Version 1.3 ("License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://www.zimbra.com/license.
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * ***** END LICENSE BLOCK *****
 */
package com.zimbra.cs.index.query.parser;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;

import org.apache.lucene.analysis.Analyzer;

import com.google.common.base.Strings;
import com.zimbra.common.service.ServiceException;
import com.zimbra.common.util.ZimbraLog;
import static com.zimbra.cs.index.ZimbraQuery.*;
import com.zimbra.cs.index.query.BuiltInQuery;
import com.zimbra.cs.mailbox.MailServiceException;
import com.zimbra.cs.mailbox.Mailbox;
import com.zimbra.cs.service.util.ItemId;

/**
 * Visitor for the query parser generated by JavaCC.
 * <p>
 * This way, there is no Java code in the grammar file.
 *
 * @author ysasaki
 */
final class QueryParserVisitor implements ParserVisitor, ParserConstants, ParserTreeConstants {

    private static final Map<String, Integer> str2jj = new HashMap<String, Integer>();
    static {
        for (int i = 0; i < tokenImage.length; i++) {
            String token = tokenImage[i];
            if (token.startsWith("\"") || token.endsWith(":\"")) {
                str2jj.put(token.substring(1, token.length() - 1), i);
            }
        }
    }

    static final Map<String, Integer> folder2id = new HashMap<String, Integer>();
    static {
        folder2id.put("inbox", Mailbox.ID_FOLDER_INBOX);
        folder2id.put("trash", Mailbox.ID_FOLDER_TRASH);
        folder2id.put("junk", Mailbox.ID_FOLDER_SPAM);
        folder2id.put("sent", Mailbox.ID_FOLDER_SENT);
        folder2id.put("drafts", Mailbox.ID_FOLDER_DRAFTS);
        folder2id.put("contacts", Mailbox.ID_FOLDER_CONTACTS);
    }

    private List<BaseQuery> terms = new LinkedList<BaseQuery>();
    private String sortBy;
    private final Mailbox mailbox;
    private final Analyzer analyzer;
    private TimeZone timezone = TimeZone.getTimeZone("UTC");
    private Locale locale = Locale.ENGLISH;
    private int defaultField = CONTENT;

    QueryParserVisitor(Mailbox mbox, Analyzer analyzer) {
        this.mailbox = mbox;
        this.analyzer = analyzer;
    }

    void setTimeZone(TimeZone value) {
        timezone = value;
    }

    void setLocale(Locale value) {
        locale = value;
    }

    void setDefaultField(String field) throws ServiceException {
        Integer jj = str2jj.get(field);
        if (jj == null) {
            throw MailServiceException.QUERY_PARSE_ERROR(
                    field, null, field, -1, "UNKNOWN_QUERY_TYPE");
        }
        defaultField = jj;
    }

    @Override
    public void visit(SimpleNode node, Void data) throws QueryParserException, ServiceException {
        switch (node.id) {
            case JJTROOT:
                terms.clear();
                node.childrenAccept(this, null);
                break;
            case JJTQUERY:
                terms.addAll(toQuery(node));
                break;
            default:
                assert(false);
        }
    }

    List<BaseQuery> getQuery() {
        return terms;
    }

    String getSortBy() {
        return sortBy;
    }

    private List<BaseQuery> toQuery(SimpleNode node) throws QueryParserException, ServiceException {
        assert(node.id == JJTQUERY);

        List<BaseQuery> result = new LinkedList<BaseQuery>();
        ConjQuery conj = null;
        for (int i = 0; i < node.jjtGetNumChildren(); i++) {
            SimpleNode child = (SimpleNode) node.jjtGetChild(i);
            switch (child.id) {
                case JJTCONJUNCTION:
                    conj = toConjunction(child);
                    break;
                case JJTCLAUSE:
                    if (!result.isEmpty()) {
                        if (conj == null) {
                            result.add(new ConjQuery(AND));
                        } else {
                            result.add(conj);
                            conj = null;
                        }
                    }
                    result.add(toClause(child));
                    break;
                case JJTSORTBY:
                    processSortBy(child);
                    break;
                default:
                    assert(false);
            }
        }
        return result;
    }

    private BaseQuery toClause(SimpleNode node) throws QueryParserException, ServiceException {
        assert(node.id == JJTCLAUSE);
        int num = node.jjtGetNumChildren();
        assert(num > 0 && num <= 2);

        int mod = node.jjtGetNumChildren() > 1 ?
                toModifier((SimpleNode) node.jjtGetChild(0)) : 0;

        SimpleNode child = (SimpleNode) node.jjtGetChild(num - 1);
        switch (child.id) {
            case JJTTEXTCLAUSE:
                return toTextClause(mod, child);
            case JJTITEMCLAUSE:
                return toItemClause(mod, child);
            case JJTDATECLAUSE:
                return toDateClause(mod, child);
            case JJTQUERY:
                return toSubQuery(mod, child);
            case JJTDEFAULTCLAUSE:
                return toDefaultClause(mod, child);
            default:
                assert(false);
                return null;
        }
    }

    private BaseQuery toSubQuery(int mod, SimpleNode node)
        throws QueryParserException, ServiceException {
        assert(node.id == JJTQUERY);
        return new SubQuery(mod, toQuery(node));
    }

    private BaseQuery toTextClause(int mod, SimpleNode node)
        throws QueryParserException, ServiceException {

        assert(node.id == JJTTEXTCLAUSE);
        assert(node.jjtGetNumChildren() == 1);

        return toTerm(node.jjtGetFirstToken().kind, mod,
                (SimpleNode) node.jjtGetChild(0));
    }

    private BaseQuery toDefaultClause(int mod, SimpleNode node)
        throws QueryParserException, ServiceException {

        assert(node.id == JJTDEFAULTCLAUSE);

        return createQuery(defaultField, mod,
                node.jjtGetFirstToken(), toString(node));
    }

    private BaseQuery toItemClause(int mod, SimpleNode node)
        throws QueryParserException, ServiceException {

        assert(node.id == JJTITEMCLAUSE);
        assert(node.jjtGetNumChildren() == 1);

        return toTerm(node.jjtGetFirstToken().kind, mod,
                (SimpleNode) node.jjtGetChild(0));
    }

    private BaseQuery toDateClause(int mod, SimpleNode node)
        throws QueryParserException, ServiceException {

        assert(node.id == JJTDATECLAUSE);
        assert(node.jjtGetNumChildren() == 1);

        return toTerm(node.jjtGetFirstToken().kind, mod,
                (SimpleNode) node.jjtGetChild(0));
    }

    private BaseQuery toTerm(int kind, int mod, SimpleNode node)
        throws QueryParserException, ServiceException {

        assert(node.id == JJTDATETERM || node.id == JJTTEXTTERM ||
                node.id == JJTITEMTERM);

        if (node.jjtGetNumChildren() == 0) {
            Token token = node.jjtGetFirstToken();
            return createQuery(kind, mod, token, toString(node));
        } else {
            List<BaseQuery> sub = new LinkedList<BaseQuery>();
            ConjQuery conj = null;
            int submod = 0;
            for (int i = 0; i < node.jjtGetNumChildren(); i++) {
                SimpleNode child = (SimpleNode) node.jjtGetChild(i);
                switch (child.id) {
                    case JJTMODIFIER:
                        submod = toModifier(child);
                        break;
                    case JJTTEXTTERM:
                    case JJTITEMTERM:
                    case JJTDATETERM:
                        if (!sub.isEmpty()) {
                            if (conj == null) {
                                sub.add(new ConjQuery(AND));
                            } else {
                                sub.add(conj);
                                conj = null;
                            }
                        }
                        sub.add(toTerm(kind, submod, child));
                        submod = 0;
                        break;
                    case JJTCONJUNCTION:
                        conj = toConjunction(child);
                        break;
                    default:
                        assert(false);
                }
            }
            return new SubQuery(mod, sub);
        }
    }

    private String toString(SimpleNode node) {
        assert(node.jjtGetNumChildren() == 0);

        switch (node.id) {
            case JJTTEXTTERM:
            case JJTITEMTERM:
            case JJTDEFAULTCLAUSE:
                return toString(node.jjtGetFirstToken());
            case JJTDATETERM:
                Token token = node.jjtGetFirstToken();
                switch (token.kind) {
                    case PLUS:
                    case MINUS:
                        return token.image + toString(token.next);
                    default:
                        return toString(token);
                }
            default:
                assert(false);
                return "";
        }

    }

    private String toString(Token token) {
        switch (token.kind) {
            case TERM:
                return token.image;
            case QUOTED_TERM:
            case BRACED_TERM:
                // trim
                return token.image.substring(1, token.image.length() - 1);
            default:
                assert(false);
                return "";
        }
    }

    private ConjQuery toConjunction(SimpleNode node) {
        assert(node.id == JJTCONJUNCTION);
        assert(node.jjtGetFirstToken().kind == AND ||
                node.jjtGetFirstToken().kind == OR);
        return new ConjQuery(node.jjtGetFirstToken().kind);
    }

    private int toModifier(SimpleNode node) {
        assert(node.id == JJTMODIFIER);
        switch (node.jjtGetFirstToken().kind) {
            case PLUS:
                return PLUS;
            case MINUS:
            case NOT:
                return MINUS;
            default:
                return 0;
        }
    }

    private void processSortBy(SimpleNode node) {
        assert(node.id == JJTSORTBY);
        sortBy = node.jjtGetFirstToken().next.image;
    }

    private BaseQuery createQuery(int kind, int mod, Token token, String text)
        throws QueryParserException, ServiceException {

        switch (kind) {
          case HAS:
            if (text.equalsIgnoreCase("attachment")) {
                return new AttachmentQuery(mailbox, mod, "any");
            } else {
                return new HasQuery(mailbox, mod, text);
            }
          case ATTACHMENT:
            return new AttachmentQuery(mailbox, mod, text);
          case TYPE:
            return new TypeQuery(mailbox, mod, text);
          case ITEM:
            return ItemQuery.Create(mailbox, mod, text);
          case UNDERID:
          case INID: {
              ItemId iid = null;
              int subfolderSplit = text.indexOf('/');
              String iidStr;
              String subfolderPath = null;
              if (subfolderSplit > 0) {
                  iidStr = text.substring(0, subfolderSplit);
                  subfolderPath = text.substring(subfolderSplit+1);
              } else {
                  iidStr = text;
              }
              iid = new ItemId(iidStr, (String) null);
              try {
                  return InQuery.Create(mailbox, mod, iid, subfolderPath, (kind == UNDERID));
              } catch (ServiceException e) {
                  // bug: 18623 -- dangling mountpoints create problems with 'is:remote'
                  ZimbraLog.index.debug("Ignoring INID/UNDERID clause b/c of ServiceException", e);
                  return InQuery.Create(mailbox, mod, InQuery.IN_NO_FOLDER, false);
              }
          }
          case UNDER:
          case IN: {
              Integer folderId = folder2id.get(text.toLowerCase());
              if (folderId != null) {
                  return InQuery.Create(mailbox, mod, folderId, (kind == UNDER));
              } else {
                  return InQuery.Create(mailbox, mod, text, (kind == UNDER));
              }
          }
          case TAG:
              return new TagQuery(mailbox, mod, text, true);
          case IS:
              try {
                  return BuiltInQuery.getQuery(text.toLowerCase(), mailbox, analyzer, mod);
              } catch (IllegalArgumentException e) {
                  throw new QueryParserException("UNKNOWN_TEXT_AFTER_IS", token);
              }
          case CONV:
              return ConvQuery.create(mailbox, mod, text);
          case CONV_COUNT:
              return ConvCountQuery.create(mod, kind, text);
          case DATE:
          case DAY:
          case WEEK:
          case MONTH:
          case YEAR:
          case AFTER:
          case BEFORE:
          case CONV_START:
          case CONV_END:
          case APPT_START:
          case APPT_END: {
              DateQuery query = new DateQuery(kind);
              query.parseDate(text, timezone, locale);
              return query;
          }
          case TOFROM:
          case TOCC:
          case FROMCC:
          case TOFROMCC:
              if (Strings.isNullOrEmpty(text)) {
                 throw new QueryParserException("MISSING_TEXT_AFTER_TOFROMCC", token);
              }
              return AddrQuery.createFromTarget(mailbox, analyzer, mod, kind, text);
          case FROM:
              if (Strings.isNullOrEmpty(text)) {
                  throw new QueryParserException("MISSING_TEXT_AFTER_TOFROMCC", token);
              }
              return SenderQuery.create(mailbox, analyzer, mod, kind, text);
          case TO:
          case ENVTO:
          case ENVFROM:
          case CC:
              if (Strings.isNullOrEmpty(text)) {
                  throw new QueryParserException("MISSING_TEXT_AFTER_TOFROMCC", token);
              }
              if (text.startsWith("@")) {
                  return new DomainQuery(mailbox, mod, kind, text);
              }
            return new TextQuery(mailbox, analyzer, mod, kind, text);
          case MODSEQ:
            return new ModseqQuery(mod, kind, text);
          case SIZE:
          case BIGGER:
          case SMALLER:
              return new SizeQuery(mod, kind, text);
          case SUBJECT:
              return SubjectQuery.create(mailbox, analyzer, mod, kind, text);
          default:
              return new TextQuery(mailbox, analyzer, mod, kind, text);
        }
    }
}
