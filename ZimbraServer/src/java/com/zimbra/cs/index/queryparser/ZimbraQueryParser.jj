/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Server
 * Copyright (C) 2004, 2005, 2006, 2007 Zimbra, Inc.
 * 
 * The contents of this file are subject to the Yahoo! Public License
 * Version 1.0 ("License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://www.zimbra.com/license.
 * 
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * ***** END LICENSE BLOCK *****
 */
options {
    STATIC = false;
//    DEBUG_LOOKAHEAD = true;
//    DEBUG_PARSER = true ;
//    DEBUG_TOKEN_MANAGER = true ;
    ERROR_REPORTING = true;
    JAVA_UNICODE_ESCAPE=true;
//    OPTIMIZE_TOKEN_MANAGER=true;
    IGNORE_CASE=true;
}
 

PARSER_BEGIN(ZimbraQueryParser)

package com.zimbra.cs.index.queryparser;

import java.util.TimeZone;
import java.util.Locale;

import com.zimbra.cs.index.*;
import com.zimbra.cs.mailbox.Mailbox;
import com.zimbra.common.service.ServiceException;
import com.zimbra.cs.service.util.ItemId;
import com.zimbra.cs.mailbox.MailServiceException;
import com.zimbra.common.util.ZimbraLog;

import org.apache.lucene.analysis.Analyzer;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
 
public final class ZimbraQueryParser {

    private static HashMap<String, Integer>  sFolderStrMap;
    
    private static abstract class GetQueryCallback {
        public abstract ZimbraQuery.BaseQuery execute(Mailbox mailbox, Analyzer analyzer, int modifier) throws ServiceException;
    } 

	private int mDefaultField;
    
    private static HashMap<String, GetQueryCallback> sIsStrMap;

    static {
        /* Well-known folder name string map */
        sFolderStrMap = new HashMap<String, Integer>();
        sFolderStrMap.put("inbox",    new Integer(Mailbox.ID_FOLDER_INBOX));
        sFolderStrMap.put("trash",    new Integer(Mailbox.ID_FOLDER_TRASH));
        sFolderStrMap.put("junk",     new Integer(Mailbox.ID_FOLDER_SPAM));
        sFolderStrMap.put("sent",     new Integer(Mailbox.ID_FOLDER_SENT));
        sFolderStrMap.put("drafts",   new Integer(Mailbox.ID_FOLDER_DRAFTS));
        sFolderStrMap.put("contacts", new Integer(Mailbox.ID_FOLDER_CONTACTS));

        /* is: string map */
        sIsStrMap = new HashMap<String, GetQueryCallback>();

        // expressing this in java is soooo ugly.... <sigh>
        sIsStrMap.put("read",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.ReadQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("unread",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.ReadQuery(mbx, analyze, modifier, false);
                      } } );

        sIsStrMap.put("flagged",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.FlaggedQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("unflagged",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                              return new ZimbraQuery.FlaggedQuery(mbx, analyze, modifier, false);
                      } } );

        sIsStrMap.put("draft",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                              return new ZimbraQuery.DraftQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("received",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.SentQuery(mbx, analyze, modifier, false);
                      } } );
                      
        sIsStrMap.put("replied",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.RepliedQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("unreplied",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.RepliedQuery(mbx, analyze, modifier, false);
                      } } );
                      
        sIsStrMap.put("forwarded",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.ForwardedQuery(mbx, analyze, modifier, true);
                      } } );

        sIsStrMap.put("unforwarded",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.ForwardedQuery(mbx, analyze, modifier, false);
                      } } );

        sIsStrMap.put("invite",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.IsInviteQuery(mbx, analyze, modifier, true);
                      } } );
                      
        sIsStrMap.put("anywhere",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.InQuery.Create(mbx, analyze, modifier, ZimbraQuery.InQuery.IN_ANY_FOLDER, false);
                      } } );
                      
        sIsStrMap.put("local", 
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.InQuery.Create(mbx, analyze, modifier, ZimbraQuery.InQuery.IN_LOCAL_FOLDER, false);
                      } } );

        sIsStrMap.put("remote",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.InQuery.Create(mbx, analyze, modifier, ZimbraQuery.InQuery.IN_REMOTE_FOLDER, true);
                      } } );

        sIsStrMap.put("solo",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.ConvCountQuery.create(mbx, analyze, modifier, ZimbraQueryParser.CONV_COUNT, "1");
                      } } );
                      
        sIsStrMap.put("sent",  /* sent by me */ 
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.SentQuery(mbx, analyze, modifier, true);
                      } } );
                      
        sIsStrMap.put("tome",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.MeQuery.create(mbx, analyze, modifier, ZimbraQuery.ADDR_BITMASK_TO);
                      } } );
                      
        sIsStrMap.put("fromme", /* sent by me */ 
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return new ZimbraQuery.SentQuery(mbx, analyze, modifier, true);
                      } } );
        
        sIsStrMap.put("ccme",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.MeQuery.create(mbx, analyze, modifier, ZimbraQuery.ADDR_BITMASK_CC);
                      } } );
                      
        sIsStrMap.put("tofromme",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.MeQuery.create(mbx, analyze, modifier, ZimbraQuery.ADDR_BITMASK_TO | ZimbraQuery.ADDR_BITMASK_FROM);
                      } } );
                      
        sIsStrMap.put("toccme",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.MeQuery.create(mbx, analyze, modifier, ZimbraQuery.ADDR_BITMASK_TO | ZimbraQuery.ADDR_BITMASK_CC);
                      } } );
                      
        sIsStrMap.put("fromccme",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.MeQuery.create(mbx, analyze, modifier, ZimbraQuery.ADDR_BITMASK_FROM | ZimbraQuery.ADDR_BITMASK_CC);
                      } } );
                      
        sIsStrMap.put("tofromccme",
                      new GetQueryCallback() { public ZimbraQuery.BaseQuery execute(Mailbox mbx, Analyzer analyze, int modifier) throws ServiceException {
                          return ZimbraQuery.MeQuery.create(mbx, analyze, modifier, ZimbraQuery.ADDR_BITMASK_TO | ZimbraQuery.ADDR_BITMASK_FROM | ZimbraQuery.ADDR_BITMASK_CC);
                      } } );
    }
    
    public ZimbraQuery.BaseQuery GetFieldQuery(int modifier, int target, String targetImg, String tok) throws ParseException, ServiceException, MailServiceException
    {
        return ZimbraQuery.FieldQuery.Create(mMailbox, mAnalyzer, modifier,target,targetImg, tok);
    }
    
    public static final ParseException parseException(String s, String code, Token t) throws ParseException {
       ParseException pe = new ParseException(s, code);
       pe.currentToken = t;
       return pe;	
    }
    

    public ZimbraQuery.BaseQuery GetQuery(int modifier, int target, String tok, Token t) throws ParseException, ServiceException, MailServiceException
    {
        switch(target) {
          case HAS:
          	if (!tok.equalsIgnoreCase("attachment")) {
	            return new ZimbraQuery.HasQuery(mMailbox, mAnalyzer, modifier, tok);
            }
            tok = "any";
            // otherwise FALL THROUGH to AttachmentQuery below!
          case ATTACHMENT:
            return new ZimbraQuery.AttachmentQuery(mMailbox, mAnalyzer, modifier,tok);
          case TYPE:
            return new ZimbraQuery.TypeQuery(mMailbox, mAnalyzer, modifier,tok);
          case ITEM:
            return ZimbraQuery.ItemQuery.Create(mMailbox, mAnalyzer, modifier, tok);
          case UNDERID:
          case INID:
          {
              ItemId iid = null;
              int subfolderSplit = tok.indexOf('/');
              String iidStr;
              String subfolderPath = null;
              if (subfolderSplit > 0) {
                  iidStr = tok.substring(0, subfolderSplit);
                  subfolderPath = tok.substring(subfolderSplit+1);
              } else {
                  iidStr = tok;
              }
              iid = new ItemId(iidStr, (String)null);
              try {
              	return ZimbraQuery.InQuery.Create(mMailbox, mAnalyzer, modifier, iid, subfolderPath, (target == UNDERID));
              } catch (ServiceException e) {
                  // bug: 18623 -- dangling mountpoints create problems with 'is:remote'
			      ZimbraLog.index.debug("Ignoring INID/UNDERID clause b/c of ServiceException: "+e);
                  return ZimbraQuery.InQuery.Create(mMailbox, mAnalyzer, modifier, ZimbraQuery.InQuery.IN_NO_FOLDER, false);
              }
          }
          case UNDER:
          case IN:
          {
              Integer folderId = sFolderStrMap.get(tok.toLowerCase());
              if (folderId != null) {
                  return ZimbraQuery.InQuery.Create(mMailbox, mAnalyzer, modifier, folderId, (target == UNDER));
              } else {
                  return ZimbraQuery.InQuery.Create(mMailbox, mAnalyzer, modifier, tok, (target == UNDER));
              }
          }
          case TAG:
            return new ZimbraQuery.TagQuery(mMailbox, mAnalyzer, modifier, tok, true);
          case IS:
            GetQueryCallback cback = sIsStrMap.get(tok.toLowerCase());
            if (cback != null) {
                return cback.execute(mMailbox, mAnalyzer, modifier);
            } else {
                throw parseException("Unknown text after is: in query string", "UNKNOWN_TEXT_AFTER_IS", t);
            }
          case CONV:
            return ZimbraQuery.ConvQuery.create(mMailbox, mAnalyzer, modifier, tok);
          case CONV_COUNT:
            return ZimbraQuery.ConvCountQuery.create(mMailbox, mAnalyzer, modifier, target, tok);
          case DATE:
          case DAY:
          case WEEK:
          case MONTH:
          case YEAR:
          case AFTER:
          case BEFORE:
          case CONV_START:
          case CONV_END:
          case APPT_START:
          case APPT_END:
          {
              ZimbraQuery.DateQuery q = new ZimbraQuery.DateQuery(mAnalyzer, target);
              q.parseDate(modifier, tok, t, mTimeZone, mLocale);
              return q;
          }
          case TOFROM:
          case TOCC:
          case FROMCC:
          case TOFROMCC:
			if (tok == null || tok.length() < 1) {
                 throw parseException("Missing required text after a TO/FROM/CC", "MISSING_TEXT_AFTER_TOFROMCC", t);
			}
			return ZimbraQuery.AddrQuery.createFromTarget(mMailbox, mAnalyzer, modifier, target, tok);
          case FROM:
			if (tok == null || tok.length() < 1) {
                 throw parseException("Missing required text after a TO/FROM/CC", "MISSING_TEXT_AFTER_TOFROMCC", t);
			}
    			return ZimbraQuery.SenderQuery.create(mMailbox, mAnalyzer, modifier, target, tok);            
          case TO:
          case ENVTO:
          case ENVFROM:
          case CC:
            if (tok == null || tok.length() < 1) {
                throw parseException("Missing required text after a TO/FROM/CC", "MISSING_TEXT_AFTER_TOFROMCC", t);
            }
            if (tok.charAt(0) == '@') {
                return new ZimbraQuery.DomainQuery(mMailbox, mAnalyzer, modifier, target, tok);
            }
            return new ZimbraQuery.TextQuery(mMailbox, mAnalyzer, modifier,target,tok);
          case MODSEQ:
            return new ZimbraQuery.ModseqQuery(mMailbox, mAnalyzer, modifier, target, tok);
          case SIZE:
          case BIGGER:
          case SMALLER:
            return new ZimbraQuery.SizeQuery(mAnalyzer, modifier,target,tok);
          case SUBJECT:
            return ZimbraQuery.SubjectQuery.create(mMailbox, mAnalyzer, modifier, target, tok);
          default:
            return new ZimbraQuery.TextQuery(mMailbox, mAnalyzer, modifier,target,tok);
        }
    }
    
    private Analyzer mAnalyzer = null;
    private Mailbox mMailbox = null;
    private TimeZone mTimeZone = null;
    private Locale mLocale = null;
    
	// the query string can OPTIONALLY have a "sortby:" element which will override the
	// sortBy specified in the <SearchRequest> xml...this is basically to allow people
	// to do more with cut-and-pasted search strings
    private String mSortByStr = null;
    public String getSortByStr() { return mSortByStr; }
    
    public void init(Analyzer analyzer, Mailbox mbx, TimeZone tz, Locale locale, int defaultField) {
       mAnalyzer = analyzer;
	   mMailbox = mbx;
	   mTimeZone = tz;
	   mLocale = locale;
	   mDefaultField = defaultField;
    }
    
    public ArrayList Parse() throws ServiceException, ParseException {
        try {
            return DoParse();
        } catch(TokenMgrError e) {
            Token t = new Token();
            t.image = "";
            t.beginColumn = e.colNo;
            t.endColumn = e.colNo;
            throw parseException(e.getMessage(), "LEXICAL_ERROR", t);
        }
    }

    public static final void AddClause(ArrayList clauses, ZimbraQuery.BaseQuery q)
    {
        if (null != q) {
            if (clauses.size() > 0) {
                ZimbraQuery.BaseQuery prev = (ZimbraQuery.BaseQuery)clauses.get(clauses.size()-1);
                assert(prev.getNext() == null);
                prev.setNext(q);
            }
            clauses.add(q);
        }
    }
}
    
PARSER_END(ZimbraQueryParser)

//////////////////////////////////////////////////////////////////////
///
/// Lexical States
///


<DEFAULT>SKIP :
{ 
    " " | "\t" 
}

<DEFAULT>SKIP:
{
    "{" { SwitchTo(BRACES_STATE); }
    | "\"" { SwitchTo(QUOTED_STATE); }
}

<DEFAULT>TOKEN :
{
    <AND_TOKEN: ("and" | "&&") >
 |  <OR_TOKEN: ("or" | "||") >
 |  <NOT_TOKEN: ("not" | "!") >
}

<DEFAULT>TOKEN:
{
    <LPAREN: "("> 
 |  <RPAREN: ")">
}

<DEFAULT>TOKEN :
{
    <PLUS: "+">
 |  <MINUS: "-">
 |  <TEXT_TOK:  <INITIAL_TERM_CHAR> (<SUBSEQUENT_TERM_CHAR>)*>
 |  <#INITIAL_TERM_CHAR: ~["{", "}", " ", "\t", "\n", "\r", ":", "+", "-", "\"", "(", ")"]>
 |  <#SUBSEQUENT_TERM_CHAR:  <INITIAL_TERM_CHAR> | "-" | "+" | "@" >
}


<DEFAULT>TOKEN :
{
   <CONTENT:   "content:"> 
|  <SUBJECT:    "subject:">
|  <MSGID:      "msgid:">
|  <ENVTO:      "envto:">                            
|  <ENVFROM:    "envfrom:">         
|  <CONTACT:   "contact:">
|  <TO:         "to:">         
|  <FROM:       "from:">
|  <CC:         "cc:">       

|  <TOFROM:     "tofrom:">         
|  <TOCC:       "tocc:">         
|  <FROMCC:     "fromcc:">         
|  <TOFROMCC:   "tofromcc:">         

|  <IN:         "in:">  
|  <UNDER:      "under:">  
|  <INID:         "inid:">  
|  <UNDERID:      "underid:">  
|  <HAS:        "has:">
|  <FILENAME:   "filename:">
|  <TYPE:       "type:">
|  <ATTACHMENT: "attachment:">
|  <IS:         "is:">
|  <DATE:       "date:"> 
|  <DAY:        "day:"> 
|  <WEEK:       "week:"> 
|  <MONTH:      "month:"> 
|  <YEAR:       "year:"> 
|  <AFTER:      "after:">     
|  <BEFORE:     "before:">   
|  <SIZE:       "size:">       
|  <BIGGER: <BIGGER_STR>|<LARGER>>
|  <#BIGGER_STR:"bigger:">
|  <#LARGER:    "larger:">
|  <SMALLER:    "smaller:">    
|  <TAG:        "tag:">
|  <MESSAGE:    "message:">
|  <MY:         "my:">
|  <MODSEQ:     "modseq:">
|  <CONV:       "conv:">
|  <CONV_COUNT: "conv-count:">  
|  <CONV_MINM:  "conv-minm:">
|  <CONV_MAXM:  "conv-maxm:">
|  <CONV_START: "conv-start:"> 
|  <CONV_END:   "conv-end:">  
|  <APPT_START:   "appt-start:">  
|  <APPT_END:   "appt-end:">  
|  <AUTHOR:     "author:">
|  <TITLE:      "title:">
|  <KEYWORDS:   "keywords:">
|  <COMPANY:    "company:">
|  <METADATA:   "metadata:">
|  <ITEM:       "item:">
|  <SORTBY:     "sortby:">
|  <SORT:       "sort:">
|  <FIELD: <FIELD1> | <FIELD2>>
|  <#FIELD1:      "field" ("[" <INITIAL_TERM_CHAR> (<SUBSEQUENT_TERM_CHAR>)* "]")? ":">
|  <#FIELD2:     "#" <INITIAL_TERM_CHAR> (<SUBSEQUENT_TERM_CHAR>)* ":">
}

<BRACES_STATE>SKIP:
{
    "}"  { SwitchTo(DEFAULT); } 
}

<BRACES_STATE>TOKEN :
{
    <ERROR_BRACES_WITH_NEWLINE: (["\n", "\r"])>  { SwitchTo(DEFAULT); }
    |    <BRACES_TOK: (~["}","\n","\r"])+>
}


<QUOTED_STATE>SKIP:
{
    "\""  { SwitchTo(DEFAULT); } 
}

<QUOTED_STATE>TOKEN :
{
    <ERROR_QUOTE_WITH_NEWLINE: (["\n", "\r"])>  { SwitchTo(DEFAULT); }
    |    <QUOTED_TOK: (~["\"","\n","\r"])+>
}

//////////////////////////////////////////////////////////////////////
///
/// Parser States
///

ZimbraQuery.BaseQuery Conjunction() :
{
}
{
      <AND_TOKEN> { return new ZimbraQuery.ConjQuery(mAnalyzer, AND_TOKEN); }
      |  <OR_TOKEN>  { return new ZimbraQuery.ConjQuery(mAnalyzer, OR_TOKEN); }
      |  { return new ZimbraQuery.ConjQuery(mAnalyzer, AND_TOKEN); }
}

int Modifier() :
{
    Token mod = null;
}
{
    <PLUS> { return PLUS; }
    |  <MINUS> { return MINUS; }
    |  <NOT_TOKEN> { return MINUS; }
    |  {} 
    {
        return 0;
    }
}

int DateModifier() :
{
    Token mod = null;
}
{
    <NOT_TOKEN> { return NOT_TOKEN; }
    |  {} 
    {
        return 0;
    }
}

void SortBy() :
{
    Token t = null;
}
{
   (<SORTBY>|<SORT>) t=<TEXT_TOK> { mSortByStr = t.image; }
   | {}
}



/***
 *
 * Text target but after we have a target (thing to the left of the :...)
 *
 **/
ZimbraQuery.BaseQuery Rhs_Text(int target) throws ServiceException :
{
    ArrayList clauses = new ArrayList();
    Token t;
    int modifier = 0;
    ZimbraQuery.BaseQuery clause = null;
}
{
    (
        <LPAREN> modifier=Modifier() clause=Rhs_Text(target) { clause.setModifier(modifier);  AddClause(clauses,clause); }
        (
            clause=Conjunction() { AddClause(clauses,clause); }
            modifier=Modifier() clause=Rhs_Text(target) { clause.setModifier(modifier); AddClause(clauses,clause); }
         )*
        <RPAREN> { return new ZimbraQuery.SubQuery(mAnalyzer, 0,clauses); }
    )   
    
    |  (t=<TEXT_TOK>|t=<QUOTED_TOK>) { return GetQuery(modifier, target, t.image, t); }
}

/***
 *
 * item:  target
 *
 * Like Rhs_Text, except we allow {}'s, so these are legal:
 *   'item:{1,2,3}', 'item:({1,2,3} or {4,5,6})'
 *
 **/
ZimbraQuery.BaseQuery Rhs_Item(int target) throws ServiceException :
{
    ArrayList clauses = new ArrayList();
    Token t;
    int modifier = 0;
    ZimbraQuery.BaseQuery clause = null;
}
{
    (
        <LPAREN> modifier=Modifier() clause=Rhs_Item(target) { clause.setModifier(modifier);  AddClause(clauses,clause); }
        (
            clause=Conjunction() { AddClause(clauses,clause); }
            modifier=Modifier() clause=Rhs_Item(target) { clause.setModifier(modifier); AddClause(clauses,clause); }
        )*
        <RPAREN> { return new ZimbraQuery.SubQuery(mAnalyzer, 0,clauses); }
    )   
    
    |  (t=<TEXT_TOK>|t=<QUOTED_TOK>|t=<BRACES_TOK>) { return GetQuery(modifier, target, t.image, t); }
}

/***
 *
 * Like Rhs_Text but allows field parameter for field:
 *
 **/
ZimbraQuery.BaseQuery Rhs_Field(int target, String img) throws ServiceException :
{
    ArrayList clauses = new ArrayList();
    Token t;
    int modifier = 0;
    ZimbraQuery.BaseQuery clause = null;
}
{
    (
        <LPAREN> modifier=Modifier() clause=Rhs_Field(target, img) { clause.setModifier(modifier);  AddClause(clauses,clause); }
        (
            clause=Conjunction() { AddClause(clauses,clause); }
            modifier=Modifier() clause=Rhs_Field(target, img) { clause.setModifier(modifier); AddClause(clauses,clause); }
         )*
        <RPAREN> { return new ZimbraQuery.SubQuery(mAnalyzer, 0,clauses); }
    )   
    
    |  (t=<TEXT_TOK>|t=<QUOTED_TOK>) { return GetFieldQuery(modifier, target, img, t.image); }
}



/***
 *
 * special date target (because dates allow starting - (minus) signs, and we don't want to interpret those as a NOT, like
 * we do in other cases
 *
 **/
ZimbraQuery.BaseQuery Rhs_Date(int target) throws ServiceException :
{
    ArrayList clauses = new ArrayList();
    Token t,u;
    int modifier = 0;
    ZimbraQuery.BaseQuery clause = null;
}
{
    (
        <LPAREN> modifier=DateModifier() clause=Rhs_Date(target) { if (modifier == NOT_TOKEN) { clause.setModifier(MINUS); } AddClause(clauses,clause); }
        (
            clause=Conjunction() { AddClause(clauses,clause); }
            modifier=DateModifier() clause=Rhs_Date(target) { if (modifier == NOT_TOKEN) { clause.setModifier(MINUS); } AddClause(clauses,clause); }
        )*
        <RPAREN> { return new ZimbraQuery.SubQuery(mAnalyzer, 0,clauses); }
    )   
        
    |  (u=<MINUS>|u=<PLUS>)(t=<TEXT_TOK>|t=<QUOTED_TOK>) { return GetQuery(0, target, u.image+t.image, t); }
    |  (t=<TEXT_TOK>|t=<QUOTED_TOK>) { return GetQuery(0, target, t.image, t); }
}


//////////////////////////////
//
// Main grammar
//

ZimbraQuery.BaseQuery Clause() throws ServiceException :
{
    Token t = null;

    ZimbraQuery.BaseQuery q = null;
    ArrayList subExp = null;
}
{
    <LPAREN> subExp=Query() <RPAREN> { return new ZimbraQuery.SubQuery(mAnalyzer, 0, subExp); }
    
    | (
          (
  	           t=<MSGID>|t=<ENVFROM>|t=<ENVTO>|t=<FROM>|t=<TO>|t=<CC>|t=<CONTACT>
  	          | t=<TOFROM>|t=<TOCC>|t=<FROMCC>|t=<TOFROMCC> 
  		      | t=<CONTENT>|t=<MESSAGE>|t=<SUBJECT>|t=<IN>|t=<INID>|t=<UNDER>|t=<UNDERID>
       		  |  t=<TYPE>|t=<ATTACHMENT>|t=<HAS>|t=<FILENAME>|t=<AUTHOR>|t=<TITLE>|t=<KEYWORDS>|t=<COMPANY>|t=<METADATA>
	     	  | t=<MY>|t=<IS>|t=<TAG>|t=<CONV>|t=<CONV_COUNT>|t=<CONV_MINM>|t=<CONV_MAXM>
	  	      | t=<SIZE>|t=<BIGGER>|t=<SMALLER>|t=<MODSEQ>
           ) q = Rhs_Text(t.kind)
      
        | (t=<FIELD>) q = Rhs_Field(t.kind, t.image) 
        | (t=<ITEM>) q = Rhs_Item(t.kind)
        | (t=<DATE>|t=<DAY>|t=<MONTH>|t=<WEEK>|t=<YEAR>|t=<AFTER>|t=<BEFORE>|t=<CONV_START>|t=<CONV_END>|t=<APPT_START>|t=<APPT_END>) q = Rhs_Date(t.kind)
        | (t=<TEXT_TOK>|t=<QUOTED_TOK>) { return GetQuery(0,mDefaultField,t.image, t); }
     )
     { return q; }

}

ArrayList Query() throws ServiceException :
{
    ZimbraQuery.BaseQuery clause = null;
    ArrayList clauses = new ArrayList();
    int modifier;
}
{
    SortBy() modifier=Modifier() clause=Clause() SortBy() { if (clause != null) { clause.setModifier(modifier); AddClause(clauses,clause); } }
    (
        clause=Conjunction() { AddClause(clauses,clause); }
        modifier=Modifier() clause=Clause() { if (clause != null) { clause.setModifier(modifier); AddClause(clauses,clause); } }
        SortBy()
        )* {}
    {
        return clauses;
    }
}

ArrayList DoParse() throws ServiceException :
{
    ArrayList clauses;
}
{
    clauses=Query() ("\r"|<EOF>)? {
        return clauses;
    }
}

