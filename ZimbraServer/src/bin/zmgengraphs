#!/usr/bin/perl
# 
# ***** BEGIN LICENSE BLOCK *****
# Version: ZPL 1.1
# 
# The contents of this file are subject to the Zimbra Public License
# Version 1.1 ("License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.zimbra.com/license
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
# the License for the specific language governing rights and limitations
# under the License.
# 
# The Original Code is: Zimbra Collaboration Suite.
# 
# The Initial Developer of the Original Code is Zimbra, Inc.
# Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
# All Rights Reserved.
# 
# Contributor(s):
# 
# ***** END LICENSE BLOCK *****
# 

use strict;
use lib '/opt/zimbra/zimbramon/lib';
use lib '/opt/zimbra/zimbramon/lib/Zimbra/Mon';

my $DEBUG=0;

use DBI;
use Time::Local;
use Logger;

my %graphTimeInfo = (
	"hour" => {
		"count" => 24,
		"step" => 3600,
		},
	"day" => {
		"count" => 30,
		"step" => 86400,
		},
	"month" => {
		"count" => 12,
		"step" => 86400,
		},
	"year" => {
		"count" => 2,
		"step" => 86400,
		}
);

my %graphAppInfo = (
	"mta" => {
		"columns" => ["msg_count", "msg_bytes"],
		},
	"amavis" => {
		"columns" => ["msg_count", "spam_count", "virus_count"],
		}
);

my $baseDir = "/opt/zimbra";
my $logDir = "$baseDir/log";

my $data_source="dbi:mysql:database=zimbra_logger;".
	"mysql_read_default_file=/opt/zimbra/conf/my.logger.cnf;".
	"mysql_socket=/opt/zimbra/logger/db/mysql.sock";

my $username="zimbra";
my $password = `/opt/zimbra/bin/zmlocalconfig -s -m nokey zimbra_logger_mysql_password`;
chomp $password;

my $dbh = DBI->connect($data_source, $username, $password);

if (!$dbh) { 
	print STDERR "DB: Can't connect to $data_source: $DBI::errstr\n";
	exit 1;
}

sub tsToSqlTime {
	my $ts = shift;
	my $dayTrunc = shift;
	# 2005-09-18 04:03:33
	my @tm = localtime($ts);

	if (defined($dayTrunc)) {
		return sprintf ("%4d-%02d-%02d %02d:%02d:%02d",
		$tm[5]+1900,$tm[4]+1,$tm[3],0,0,0);
	} else {
		# Truncate at hours.
		return sprintf ("%4d-%02d-%02d %02d:%02d:%02d",
		$tm[5]+1900,$tm[4]+1,$tm[3],$tm[2],0,0);
	}
}

sub sqlTimeToTs {
	my $sqlTime = shift;
	# 2005-09-18 04:03:33
	return timelocal(substr($sqlTime,17,2),substr($sqlTime,14,2),
	substr($sqlTime,11,2),substr($sqlTime,8,2),
	(substr($sqlTime,5,2)-1),substr($sqlTime,0,4));
}

sub sqlExec {
	my $statement = shift;
	my @args = @_;

	my $sth = $dbh->prepare($statement);

	#print "Executing $statement with @args\n\n";

	eval {
		if (!$sth->execute(@args) ) {
			die $sth->errstr;
		}
	};
	if ($@) { 
		print "Error executing $statement with @args\n";
		print $sth->errstr,"\n";
		print "$@\n";
		return undef;
	}

	return $sth;
}

sub getData {
	my $app = shift;
	my $period = shift;

	my $statement = "select * from ${app}_aggregate ".
		"where period='".$period."' ".
		"order by period_end desc limit ".
		$graphTimeInfo{$period}{count};

	my $sth = sqlExec($statement);
	my $hash = $sth->fetchall_hashref('period_end');

}

my $base = "/opt/zimbra/zimbramon/rrdtool";
my $work = "${base}/work";
my $rrd = "${base}/bin/rrdtool";

if (! -d $work) {mkdir ($work, 0777);}

#
# man -M /opt/zimbra/zimbramon/rrdtool/man rrd{graph,update}
#
# GTM:GST:MTM:MST:LTM:LST:LPR:LFM
# 
# You have to configure three elements making up the x-axis labels and grid. The base grid (G??),
# the major grid (M??) and the labels (L??). The configuration is based on the idea that you first
# specify a well known amount of time (?TM) and then say how many times it has to pass between each
# grid line or label (?ST). For the label you have to define two additional items: The precision of
# the label in seconds (LPR) and the strftime format used to generate the text of the label (LFM).
# 
# The ?TM elements must be one of the following keywords: SECOND, MINUTE, HOUR, DAY, WEEK, MONTH or
# YEAR.

my $xlabel;

if ($period eq "hour") {
	$xlabel = '-x MINUTE:30:HOUR:1:HOUR:4:0:%H --no-minor';
} elsif ($period eq "day") {
	$xlabel = '-x WEEK:1:WEEK:2:WEEK:2:604800:%d/%b';
} elsif ($period eq "month") {
	$xlabel = '-x DAY:7:MONTH:1:DAY:14:2592000:%b --no-minor';
} elsif ($period eq "year") {
	$xlabel = '-x DAY:15:MONTH:1:MONTH:2:2592000:%b --no-minor';
}

foreach my $app ("mta", "amavis") {
	foreach my $period ("hour", "day", "month", "year") {
		my $data = getData($app, $period);

		foreach my $column ( @{$graphAppInfo{$app}{columns}} ) {
			my $db = "${work}/${app}.${period}.${column}.rrd";
			my $graph = "${work}/${app}.${period}.${column}.gif";
			unlink -f $db;

			print "Generating $period graph for $app\n";
			`$rrd create $db -b '-5y' -s $graphTimeInfo{$period}{step} DS:$column:GAUGE:86400:U:U RRA:AVERAGE:0.2:1:$graphTimeInfo{$period}{count}`;

			my @rows = sort keys %$data;

			my $sts = sqlTimeToTs($rows[0]);
			my $ets = sqlTimeToTs($rows[$#rows]);

			foreach my $row (@rows) {

				print "$row - $column: $$data{$row}{$column}\n";
				my $ts = sqlTimeToTs(${row});
				`$rrd update $db ${ts}:$$data{$row}{$column}`;
			}

			my $upper = "";
			my $lower = "";
			my $unit = "";

			`$rrd graph $graph --start $sts --end $ets $upper $lower $unit $xlabel DEF:count=${db}:${column}:AVERAGE LINE1:count#ff0000:${app}${column}`;

		}
	}
}

__END__
