#!/usr/bin/perl
# 
# ***** BEGIN LICENSE BLOCK *****
# Version: ZPL 1.1
# 
# The contents of this file are subject to the Zimbra Public License
# Version 1.1 ("License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.zimbra.com/license
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
# the License for the specific language governing rights and limitations
# under the License.
# 
# The Original Code is: Zimbra Collaboration Suite.
# 
# The Initial Developer of the Original Code is Zimbra, Inc.
# Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
# All Rights Reserved.
# 
# Contributor(s):
# 
# ***** END LICENSE BLOCK *****
# 

use strict;

use lib "/opt/zimbra/zimbramon/lib/zimbrapm";
use lib "/opt/zimbra/zimbramon/lib/zimbrapm/SOAP";
use lib "/opt/zimbra/zimbramon/lib";

use DBI;
use Time::Local;

my $baseDir = "/opt/zimbra";

my $NOW = time();  #timestamp for all processing

my $data_source="dbi:mysql:database=zimbra_logger;mysql_read_default_file=/opt/zimbra/conf/my.logger.cnf;mysql_socket=/opt/zimbra/logger/db/mysql.sock";

my $username="zimbra";
my $password = `/opt/zimbra/bin/zmlocalconfig -s -m nokey zimbra_logger_mysql_password`;
chomp $password;

my $dbh = DBI->connect($data_source, $username, $password);

if (!$dbh) { 
	print STDERR "DB: Can't connect to $data_source: $DBI::errstr\n";
	exit 1;
}

processMta();

processClam();

processAmavis();

processSendmail();

processZimbramon();

aggregateMta();

aggregateAmavis();

sub aggregateMta {

	foreach my $periodType ("hour", "day", "month", "year") {

		#print "Aggregating $periodType for mta\n";
		my $lastPeriod = getLastAggPeriod ("mta", $periodType);

		my $periods = getAggPeriods($lastPeriod, $periodType);

		my $periodStart = $lastPeriod;
		for (my $i = 0; $i <= $#$periods; $i++) {
			my $periodEnd = $$periods[$i];
			print "Aggregating $periodType mta from $periodStart to $periodEnd\n";

			my $count;
			my $bytes;
			if ($periodType eq "hour") {
				# From the mta table
				my $sth = sqlExec("select count(*) from mta where ".
					"arrive_time >= '".$periodStart."' and ".
					"arrive_time <= '".$periodEnd."'");

				my $ary = $sth->fetchall_arrayref;
				if (@$ary) {
					$count = ${$$ary[0]}[0];
				}

				$sth = sqlExec("select sum(bytes) from mta where ".
					"arrive_time >= '".$periodStart."' and ".
					"arrive_time <= '".$periodEnd."'");

				$ary = $sth->fetchall_arrayref;
				if (@$ary) {
					$bytes = ${$$ary[0]}[0];
				}

				$sth = sqlExec("insert into mta_aggregate ".
				"(period_start, period_end, period, msg_count, msg_bytes) ".
				"values (?,?,?,?,?)",
				$periodStart, $periodEnd, $periodType, $count, $bytes);

			} else {
				# From the mta_aggregate table

				my $prevPeriod;
				if ($periodType eq "day") {
					$prevPeriod="hour";
				} elsif ($periodType eq "month") {
					$prevPeriod="day";
				} else {
					$prevPeriod="month";
				}

				my $sth = sqlExec("select sum(msg_bytes), sum(msg_count) ".
					"from mta_aggregate where ".
					"period_start >= '".$periodStart."' and ".
					"period_end <= '".$periodEnd."' and period='".$prevPeriod."'");

				my $ary = $sth->fetchall_arrayref;
				if (@$ary) {
					$bytes = ${$$ary[0]}[0];
					$count = ${$$ary[0]}[1];
				}

				$sth = sqlExec("delete from mta_aggregate ".
					"where period_start='".$periodStart."' and ".
					"period_end = '".$periodEnd."' and ".
					"period = '".$periodType."'");

				$sth = sqlExec("insert into mta_aggregate ".
				"(period_start, period_end, period, msg_count, msg_bytes) ".
				"values (?,?,?,?,?)",
				$periodStart, $periodEnd, $periodType, $count, $bytes);
			}

			$periodStart = $periodEnd;
		}

	}

}

sub aggregateAmavis {

	foreach my $periodType ("hour", "day", "month", "year") {

		my $lastPeriod = getLastAggPeriod ("amavis", $periodType);

		my $periods = getAggPeriods($lastPeriod, $periodType);

		my $periodStart = $lastPeriod;
		for (my $i = 0; $i <= $#$periods; $i++) {
			my $periodEnd = $$periods[$i];
			print "Aggregating $periodType amavis from $periodStart to $periodEnd\n";

			my $count;
			my $spam;
			my $virus;
			if ($periodType eq "hour") {
				# From the amavis table
				my $sth = sqlExec("select count(*) from amavis where ".
					"arrive_time >= '".$periodStart."' and ".
					"arrive_time <= '".$periodEnd."'");

				my $ary = $sth->fetchall_arrayref;
				if (@$ary) {
					$count = ${$$ary[0]}[0];
				}

				$sth = sqlExec("select count(*) from amavis where ".
					"arrive_time >= '".$periodStart."' and ".
					"arrive_time <= '".$periodEnd."' and ".
					"status = 'SPAM'");

				$ary = $sth->fetchall_arrayref;
				if (@$ary) {
					$spam = ${$$ary[0]}[0];
				}

				$sth = sqlExec("select count(*) from amavis where ".
					"arrive_time >= '".$periodStart."' and ".
					"arrive_time <= '".$periodEnd."' and ".
					"status = 'INFECTED'");

				$ary = $sth->fetchall_arrayref;
				if (@$ary) {
					$virus = ${$$ary[0]}[0];
				}

				$sth = sqlExec("insert into amavis_aggregate ".
				"(period_start, period_end, period, msg_count, ".
				"spam_count, virus_count) ".
				"values (?,?,?,?,?,?)",
				$periodStart, $periodEnd, $periodType, $count, $spam, $virus);

			} else {
				# From the amavis_aggregate table

				my $prevPeriod;
				if ($periodType eq "day") {
					$prevPeriod="hour";
				} elsif ($periodType eq "month") {
					$prevPeriod="day";
				} else {
					$prevPeriod="month";
				}

				my $sth = sqlExec("select sum(msg_count), sum(spam_count), ".
					"sum(virus_count) ".
					"from amavis_aggregate where ".
					"period_start >= '".$periodStart."' and ".
					"period_end <= '".$periodEnd."' and period='".$prevPeriod."'");

				my $ary = $sth->fetchall_arrayref;
				if (@$ary) {
					$count = ${$$ary[0]}[0];
					$spam = ${$$ary[0]}[1];
					$virus = ${$$ary[0]}[2];
				}

				$sth = sqlExec("delete from amavis_aggregate ".
					"where period_start='".$periodStart."' and ".
					"period_end = '".$periodEnd."' and ".
					"period = '".$periodType."'");

				$sth = sqlExec("insert into amavis_aggregate ".
				"(period_start, period_end, period, msg_count, ".
				"spam_count, virus_count) ".
				"values (?,?,?,?,?,?)",
				$periodStart, $periodEnd, $periodType, $count, $spam, $virus);

			}

			$periodStart = $periodEnd;
		}

	}

}

sub getAggPeriods {
	my $lastPeriodEnd = shift;
	my $periodType = shift;

	# We want to return the END TIME of all the COMPLETE periods between 
	# the last aggregation and now

	my @periods = ();

	my $sqlNow = tsToSqlTime($NOW);

	my $curPeriodEnd = incSqlTime($lastPeriodEnd, $periodType);

	#print "Finding $periodType periods between $lastPeriodEnd and $sqlNow\n";
	while ( ($curPeriodEnd cmp $sqlNow) < 1) {
		#print "Period ($periodType): $curPeriodEnd\n";
		push (@periods, $curPeriodEnd);
		$curPeriodEnd = incSqlTime($curPeriodEnd, $periodType);
	}

	return (\@periods);

}

sub incSqlTime {
	my $tm = shift;
	my $period = shift;

	my $sts = sqlTimeToTs($tm);

	if ($period eq "hour") {
		$sts+=(60*60);
	} elsif ($period eq "day") {
		# Strangenes - without the +1, 10/31 + 24 hours == 10/31
		$sts+=(60*60*(24+1));
	} elsif ($period eq "month") {
		# How many days this month, this year?  Let's say 30 :(
		$sts+=(60*60*24*30);
	} elsif ($period eq "year") {
		$sts+=(60*60*24*365);
	}

	if ($period ne "hour") {
		# Truncate to day 
		return (tsToSqlTime($sts,1));
	}
	return (tsToSqlTime($sts));
}

sub tsToSqlTime {
	my $ts = shift;
	my $dayTrunc = shift;
	# 2005-09-18 04:03:33
	my @tm = localtime($ts);

	# Truncate at hours.
	if (defined($dayTrunc)) {
		return sprintf ("%4d-%02d-%02d %02d:%02d:%02d",
			$tm[5]+1900,$tm[4]+1,$tm[3],0,0,0);
	} else {
		return sprintf ("%4d-%02d-%02d %02d:%02d:%02d",
			$tm[5]+1900,$tm[4]+1,$tm[3],$tm[2],0,0);
	}
}

sub sqlTimeToTs {
	my $sqlTime = shift;
	# 2005-09-18 04:03:33
	return timelocal(substr($sqlTime,17,2),substr($sqlTime,14,2),
		substr($sqlTime,11,2),substr($sqlTime,8,2),
		(substr($sqlTime,5,2)-1),substr($sqlTime,0,4));
}

sub getLastAggPeriod {
	my $app = shift;
	my $period = shift;

	#print "Getting last agg period for $app ($period)\n";

	# For hourly, we want to return the last aggregated period,
	# or re-aggregate over the whole set of logs in the $app table

	if ($period eq "hour") {

		my $sth = sqlExec("select period_end from ${app}_aggregate ".
			"where period='".$period."' order by period_end desc limit 1");

		my $ary = $sth->fetchall_arrayref;

		if (@$ary) {
			return (${$$ary[0]}[0]);
		}

		# If we don't have a value, we'll return a period 
		# that has ended directly preceding the oldest time in 
		# the app table or a $periodType prior to now, whichever is
		# older

		my $periodAgo = getPeriodAgo($period);

		my $sth = sqlExec("select min(arrive_time) from ${app} where ".
			"arrive_time != '0000-00-00 00:00:00'");

		my $ary = $sth->fetchall_arrayref;
		my $then = ${$$ary[0]}[0];

		if ($then) {
			# Trunc at hour
			my $thenEnd = tsToSqlTime(sqlTimeToTs($then));
			if ( ($thenEnd cmp $periodAgo) < 0 ) {
				# Trunc at hours
				return ($thenEnd);
			}
		}

		return ($periodAgo);
	} else {
		# For others, we want to re-aggregate over the whole set of logs 
		# in the $app_aggregate table

		# We'll return a period 
		# that has ended directly preceding the oldest time in 
		# the app_aggregate table or a $periodType prior to now, whichever is
		# older

		my $prevPeriod;
		if ($period eq "day") {
			$prevPeriod="hour";
		} elsif ($period eq "month") {
			$prevPeriod="day";
		} else {
			$prevPeriod="month";
		}

		my $periodAgo = getPeriodAgo($period);

		$periodAgo = tsToSqlTime(sqlTimeToTs($periodAgo),1);

		my $sth = sqlExec("select min(period_start) from ${app}_aggregate where ".
			"period_start != '0000-00-00 00:00:00' ".
			"and period = '".$prevPeriod."'");

		my $ary = $sth->fetchall_arrayref;
		my $then = ${$$ary[0]}[0];

		if ($then) {
			# Trunc at day
			my $thenEnd = tsToSqlTime(sqlTimeToTs($then),1);
			if ( ($thenEnd cmp $periodAgo) < 0 ) {
				return ($thenEnd);
			}
		}

		return $periodAgo;
	}
}

sub getPeriodAgo {
	my $period = shift;
	my $then = $NOW;

	#print "Getting period ago ($period)\n";
	if ($period eq "hour") {
		$then-=(60*(60+1));
	} elsif ($period eq "day") {
		$then-=(60*60*(24+1));
	} elsif ($period eq "month") {
		# How many days this month, this year?  Let's say 30 :(
		$then-=(60*60*24*(30+1));
	} elsif ($period eq "year") {
		$then-=(60*60*24*(365+1));
	}

	return tsToSqlTime($then,1);
}

sub processMta {

	my $lastRowID = getLastRowId("mta");

	print "Processing mta entries from $lastRowID\n";

	my $sth = sqlExec("select distinct(postfix_qid) from raw_logs ".
		"where postfix_qid is not null and app ".
		"like 'postfix%' and id > '".$lastRowID."'");
	my $ary = $sth->fetchall_arrayref;

	print "Found ".scalar @$ary." messages\n";

	my $count = 0;
	if (@$ary) {
		foreach my $row (sort @$ary) {
			$count++;
			if (my $l = insertMtaMessage(parseMessage($$row[0]))) {
				$lastRowID = $l;
			}
		}
		print "Inserted $count rows\n";

		saveLastRowId("mta", $lastRowID);
	}

	deleteRawLogs("mta", $lastRowID);
}

sub processSendmail {
	# logs don't really show us much - it's all in amavisd
	my $lastRowID = getLastRowId("sendmail");

	print "Processing sendmail entries from $lastRowID\n";

	my $sth = sqlExec("select distinct(id) from raw_logs where ".
		"app='sendmail' and id > '".$lastRowID."' order by id asc");
	my $ary = $sth->fetchall_arrayref;

	print "Found ".scalar @$ary." entries\n";

	if (@$ary) {
		$lastRowID = ${@$ary[$#$ary]}[0];
		saveLastRowId("sendmail", $lastRowID);
	}
	deleteRawLogs("sendmail", $lastRowID);
}

sub processZimbramon {
	# logs don't really show us much - it's all in amavisd
	my $lastRowID = getLastRowId("zimbramon");

	print "Processing zimbramon entries from $lastRowID\n";

	my $sth = sqlExec("select distinct(id) from raw_logs where ".
		"app='zimbramon' and id > '".$lastRowID."' order by id asc");
	my $ary = $sth->fetchall_arrayref;

	print "Found ".scalar @$ary." entries\n";

	if (@$ary) {
		$lastRowID = ${@$ary[$#$ary]}[0];
		saveLastRowId("zimbramon", $lastRowID);
	}
	deleteRawLogs("zimbramon", $lastRowID);
}

sub processClam {
	# Clam logs don't really show us much - it's all in amavisd
	my $lastRowID = getLastRowId("clamd");

	print "Processing clamd entries from $lastRowID\n";

	my $sth = sqlExec("select distinct(id) from raw_logs where ".
		"app='clamd' and id > '".$lastRowID."' order by id asc");
	my $ary = $sth->fetchall_arrayref;

	print "Found ".scalar @$ary." entries\n";

	if (@$ary) {
		$lastRowID = ${@$ary[$#$ary]}[0];
		saveLastRowId("clamd", $lastRowID);
	}
	deleteRawLogs("clamd", $lastRowID);
}

sub processAmavis {
	my $lastRowID = getLastRowId("amavis");

	print "Processing amavis entries from $lastRowID\n";

	my $sth = sqlExec("select id from raw_logs where ".
		"app='amavis' and id > '".$lastRowID."' order by id asc");
	my $ary = $sth->fetchall_arrayref;

	print "Found ".scalar @$ary." entries\n";

	if (@$ary) {
		my $msg = "";
		for (my $i = 0; $i <= $#$ary; $i++) {
			my $row = $$ary[$i];

            if ($$row[0] > $lastRowID) {$lastRowID = $$row[0];}

			my $sth = sqlExec("select log_date, loghost, msg from raw_logs where id='".
				$$row[0]."'");
			my $amary = $sth->fetchall_arrayref;
			foreach my $m (@$amary) {
				my $cmsg = $$m[2];

				if ($cmsg =~ /^\([^)]+\) \.\.\./) {
					# Continuation of elided line
					# Remove leading elipses
					$cmsg =~ s/^\([^)]+\) \.\.\.//;
				}

				$msg .= $cmsg;

				if ($msg =~ /^\([^)]+\) .*\.\.\.$/) {
					# Elided log lines.  Genius.
					# Remove trailing elipses
					$msg =~ s/\.\.\.$//;
					last;
				}

				if ($msg =~ /\(([^)]+)\) (Passed|Blocked) ([^,]+), (?:LOCAL )?\[([^]]+)\] \[([^]]+)\] <([^>]*)> -> (<[^>]+>(?:,<[^>]+>)*),(?: quarantine: [^,]+,)? Message-ID: <([^>]+)>,(?: Resent-Message-ID: <[^>]+>,)? mail_id: \S+, Hits: (\S+), (\d+) ms/) {
					my $pid = $1;
					my $disp = $2;
					my $reason = $3;
					my $fromIP = $4;
					my $origIP = $5;
					my $sender = $6;
					my $recips = $7;
					my $msgid = $8;
					my $hits = $9;
					my $ms = $10;

					my @r = split (' ',$reason,2);
					$r[1] =~ s/\(//;
					$r[1] =~ s/\)//;

					my $statement = "insert into amavis ".
						"(arrive_time, host, pid, msgid, ".
						"sender, recipient, disposition, ".
						"status, reason, fromIP, origIP, hits, time)".
						"values (?,?,?,?,?,?,?,?,?,?,?,?,?)";

					sqlExec ($statement, 
						$$m[0], $$m[1], $pid, $msgid,
						$sender, $recips, $disp, 
						$r[0], $r[1], $fromIP, $origIP, $hits, $ms);

				} elsif ($msg =~ /(Passed|Blocked)/) {
					print "FAILED $$row[0]: $msg\n";
				}

				$msg = "";

			}
		}
		saveLastRowId("amavis", $lastRowID);
	}
	deleteRawLogs("amavis", $lastRowID);
}

sub getMessage {
    my $qid = shift;

	#print "Getting message $qid\n";

	my $statement =
	"select id, log_date, loghost, app, pid, msg from raw_logs ".
		"where app like \'%postfix%\' and postfix_qid = \'$qid\'";

	# print "Searching for message $qid\n";

	my $sth = sqlExec($statement);

	return $sth->fetchall_arrayref;
}

sub getLastRowId {
	my $app = shift;

	my $statement =
		"select id from processing_history where app='".$app."'";

	my $sth = sqlExec ($statement);
	if (defined ($sth)) {
		my $ary = $sth->fetchall_arrayref;
		if (scalar (@$ary)) {
			return ${$$ary[0]}[0];
		}
	} 
	return 0;
}

sub saveLastRowId {
	my $app = shift;
	my $id = shift;

	print "Saving ID $id\n";

	my $statement =
		"delete from processing_history where app='".$app."'";

	sqlExec ($statement);

	$statement = 
		"insert into processing_history (id, app) values (?,?)";

	return sqlExec ($statement,$id, $app);
}

sub sqlExec {
	my $statement = shift;
	my @args = @_;

	my $sth = $dbh->prepare($statement);

	#print "Executing $statement with @args\n\n";

	eval {
		if (!$sth->execute(@args) ) {
			 die $sth->errstr;
		}
	};
	if ($@) {
		print "Error executing $statement with @args\n";
		print $sth->errstr,"\n";
		print "$@\n";
		return undef;
	}

	return $sth;
}

sub parseMessage {
	my $qid = shift;

	#print "Parsing message $qid\n";

	my $ary = getMessage ($qid);

	my %msg = ();

	my $messageId;

	# Rows are: row_id date loghost app pid msg

	# Find the message-id first
	foreach my $row (@$ary) {
		my ($rowid, $date, $host, $app, $pid, $msg) = (@$row);
		if ($msg =~ /^${qid}: message-id=<([^>]+)>/) {
			$messageId = $1;
			$msg{$messageId}{host} = $host;
			last;
		}
	}
	if ($messageId eq "" || $msg{$messageId}{host} eq "") {
		return undef;
	}

	foreach my $row (@$ary) {
		my ($rowid, $date, $host, $app, $pid, $msg) = (@$row);

		#print "ROW: $rowid, $date, $host, $app, $pid, $msg\n\n";

		if ($msg{$messageId}{rowid} < $rowid) {$msg{$messageId}{rowid} = $rowid;}

		($msg =~ "^$qid: (removed|message-id)") && next;

		if ($msg =~ /^${qid}: client=([^[]+)\[(.*)\]/) {
			$msg{$messageId}{arriveTime} = $date;
			$msg{$messageId}{prevHost} = $1;
			$msg{$messageId}{prevIp} = $2;
			next;
		}

		if ($msg =~ /^${qid}: from=<(.*)>, size=(\d+)/) {
			$msg{$messageId}{sender} = $1?$1:"postmaster";
			$msg{$messageId}{bytes} = $2;
			next;
		}

		if ($msg =~ /^${qid}: to=<([^>]*)>, relay=([^[]+)\[?(.*?)\]?\]?, delay=\d+, status=(\S+) (.*)/) {
			if (! defined ($msg{$messageId}{recipList})) {
				$msg{$messageId}{recipList} = ();
			}
			my $r = $1;
			$msg{$messageId}{recipList}{$r}{leaveTime} = $date;
			$msg{$messageId}{recipList}{$r}{recip} = $r;
			$msg{$messageId}{recipList}{$r}{nextHost} = $2;
			$msg{$messageId}{recipList}{$r}{nextIp} = $3;
			$msg{$messageId}{recipList}{$r}{status} = $4;

			if ($5 =~ /id=([^,]+).*queued as (.*)\)/) {
				$msg{$messageId}{recipList}{$r}{amavisPid} = $1;
			}

			next;
		}

		if ($msg =~ /^${qid}: to=<([^>]*)>, orig_to=<([^>]*)>, relay=([^[]+)\[(.*)\], delay=\d+, status=(\S+) (.*)/) {
			if (! defined ($msg{$messageId}{recipList})) {
				$msg{$messageId}{recipList} = ();
			}
			my $r = $1;
			$msg{$messageId}{recipList}{$r}{leaveTime} = $date;
			$msg{$messageId}{recipList}{$r}{recip} = $r;
			$msg{$messageId}{recipList}{$r}{origRecip} = $2;
			$msg{$messageId}{recipList}{$r}{nextHost} = $3;
			$msg{$messageId}{recipList}{$r}{nextIp} = $4;
			$msg{$messageId}{recipList}{$r}{status} = $5;

			if ($6 =~ /id=([^,]+).*queued as (.*)\)/) {
				$msg{$messageId}{recipList}{$r}{amavisPid} = $1;
			}
			next;
		}

	}

	return (\%msg);
}

sub insertMtaMessage {
	my $msg = shift;
	my $last = 0;

	if (!defined ($msg)) { return undef; }

	my $statement = "insert into mta ".
		"(arrive_time, ".
		"leave_time, ".
		"host, msgid, ".
		"sender, recipient, ".
		"amavis_pid, bytes, ".
		"from_host, from_IP, ".
		"to_host, ".
		"to_IP, ".
		"status) ".
		"values (?,?,?,?,?,?,?,?,?,?,?,?,?)";

	foreach my $messageId (sort keys %{$msg}) {
		if ($$msg{$messageId}{rowid} > $last) {
			$last = $$msg{$messageId}{rowid};
		}

		foreach my $r (sort keys %{$$msg{$messageId}{recipList}}) {
			sqlExec ($statement, 
				$$msg{$messageId}{arriveTime}?
					$$msg{$messageId}{arriveTime}:
					'0000-00-00 00:00:00', 
				$$msg{$messageId}{recipList}{$r}{leaveTime}?
					$$msg{$messageId}{recipList}{$r}{leaveTime}:
					'0000-00-00 00:00:00',
				$$msg{$messageId}{host}, $messageId,
				$$msg{$messageId}{sender}, $r, 
				$$msg{$messageId}{recipList}{$r}{amavisPid}, $$msg{$messageId}{bytes}, 
				$$msg{$messageId}{prevHost}, $$msg{$messageId}{prevIp}, 
				$$msg{$messageId}{recipList}{$r}{nextHost}, 
				$$msg{$messageId}{recipList}{$r}{nextIp}, 
				$$msg{$messageId}{recipList}{$r}{status});
		}
	}
	return $last;
}

sub deleteRawLogs {
	my $app = shift;
	my $lastId = shift;

	if ($app eq "mta") {
		$app = "postfix";
	} elsif ($app eq "clamd" || $app eq "amavis" || 
		$app eq "sendmail" || $app eq "zimbramon") {
	} else {
		print STDERR "Unknown app $app in deleteRawLogs\n\n";
		return;
	}

	print "Deleting processed $app logs from raw_logs...";

    my $sth = sqlExec("delete from raw_logs where app like '".$app."%' and id <= '".$lastId."'");
	print "Done\n";
}
